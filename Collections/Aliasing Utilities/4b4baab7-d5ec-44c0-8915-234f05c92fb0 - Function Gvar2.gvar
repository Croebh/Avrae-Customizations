{
  "SimpleGroup.combatants": {
    "desc": " A list of all SimpleCombatant in this group.",
    "url": "aliasing.api.combat.SimpleGroup.combatants.combatants"
  },
  "SimpleGroup.type": {
    "desc": "The type of the object (\\\"group\\\"), to determine whether this is a group or not.",
    "url": "aliasing.api.combat.SimpleGroup.type",
    "type": {
      "name": "str"
    }
  },
  "SimpleGroup.init": {
    "desc": "What the group rolled for initiative.",
    "url": "aliasing.api.combat.SimpleGroup.init",
    "type": {
      "name": "int"
    }
  },
  "SimpleGroup.get_combatant(name)": {
    "desc": "Gets a SimpleCombatant, fuzzy searching (partial match) on name.",
    "url": "aliasing.api.combat.SimpleGroup.get_combatant",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the combatant to get."
      }
    ],
    "returns": {
      "type": "SimpleCombatant",
      "desc": "The combatant."
    }
  },
  "SimpleGroup.id": {
    "desc": "The group’s unique identifier.",
    "url": "aliasing.api.combat.SimpleGroup.id",
    "type": {
      "name": "str"
    }
  },
  "SimpleGroup.name": {
    "desc": "The name of the group.",
    "url": "aliasing.api.combat.SimpleGroup.name",
    "type": {
      "name": "str"
    }
  },
  "SimpleGroup.set_init(init: int)": {
    "desc": "Sets the group’s initiative roll.",
    "url": "aliasing.api.combat.SimpleGroup.set_init",
    "param": [
      {
        "name": "init",
        "type": [
          "int"
        ],
        "desc": "The new initiative."
      }
    ]
  },
  "SimpleEffect.combatant_name": {
    "desc": "The name of the combatant this effect is on.",
    "url": "aliasing.api.combat.SimpleEffect.combatant_name",
    "type": {
      "name": "str"
    }
  },
  "SimpleEffect.conc": {
    "desc": "Whether the effect requires concentration.",
    "url": "aliasing.api.combat.SimpleEffect.conc",
    "type": {
      "name": "bool"
    }
  },
  "SimpleEffect.desc": {
    "desc": "The description of the effect.",
    "url": "aliasing.api.combat.SimpleEffect.desc",
    "type": {
      "name": "str"
    }
  },
  "SimpleEffect.duration": {
    "desc": "The initial duration of the effect, in rounds (-1 = infinite).",
    "url": "aliasing.api.combat.SimpleEffect.duration",
    "type": {
      "name": "int"
    }
  },
  "SimpleEffect.effect": {
    "desc": "The applied passive effects of the object:```py\n{\n    attack_advantage: int\n    to_hit_bonus: str\n    damage_bonus: str\n    magical_damage: bool\n    silvered_damage: bool\n    resistances: List[Resistance]\n    immunities: List[Resistance]\n    vulnerabilities: List[Resistance]\n    ignored_resistances: List[Resistance]\n    ac_value: int\n    ac_bonus: int\n    max_hp_value: int\n    max_hp_bonus: int\n    save_bonus: str\n    save_adv: List[str]\n    save_dis: List[str]\n    check_bonus: str\n}```",
    "url": "aliasing.api.combat.SimpleEffect.effect",
    "type": {
      "name": "dict"
    }
  },
  "SimpleEffect.name": {
    "desc": "The name of the effect.",
    "url": "aliasing.api.combat.SimpleEffect.name",
    "type": {
      "name": "str"
    }
  },
  "SimpleEffect.remaining": {
    "desc": "The remaining duration of the effect, in rounds.",
    "url": "aliasing.api.combat.SimpleEffect.remaining",
    "type": {
      "name": "int"
    }
  },
  "SimpleEffect.ticks_on_end": {
    "desc": "Whether the effect duration ticks at the end of the combatant’s turn or at the start.",
    "url": "aliasing.api.combat.SimpleEffect.ticks_on_end",
    "type": {
      "name": "bool"
    }
  },
  "SimpleEffect.children": {
    "desc": "Gets the child effects of this effect.",
    "url": "aliasing.api.combat.SimpleEffect.children",
    "returns": {
      "type": "[SimpleEffect]"
    }
  },
  "SimpleEffect.parent": {
    "desc": "Gets the parent effect of this effect, or ``None`` if this effect has no parent.",
    "url": "aliasing.api.combat.SimpleEffect.parent",
    "returns": {
      "type": "SimpleEffect or None"
    }
  },
  "SimpleEffect.set_parent(parent)": {
    "desc": "Sets the parent effect of this effect.",
    "url": "aliasing.api.combat.SimpleEffect.set_parent",
    "param": [
      {
        "name": "parent",
        "type": [
          "SimpleEffect"
        ],
        "desc": "The parent."
      }
    ]
  },
  "SimpleRollResult.dice": {
    "desc": "The rolled dice (e.g. 1d20 (5)).",
    "url": "aliasing.api.functions.SimpleRollResult.dice",
    "type": {
      "name": "str"
    }
  },
  "SimpleRollResult.total": {
    "desc": "The total of the roll.",
    "url": "aliasing.api.functions.SimpleRollResult.total",
    "type": {
      "name": "int"
    }
  },
  "SimpleRollResult.full": {
    "desc": "The string representing the roll.",
    "url": "aliasing.api.functions.SimpleRollResult.full",
    "type": {
      "name": "str"
    }
  },
  "SimpleRollResult.result": {
    "desc": "The RollResult object returned by the roll.",
    "url": "aliasing.api.functions.SimpleRollResult.result",
    "type": {
      "name": "d20.RollResult"
    }
  },
  "SimpleRollResult.raw": {
    "desc": "The Expression object returned by the roll. Equivalent to SimpleRollResult.result.expr.",
    "url": "aliasing.api.functions.SimpleRollResult.raw",
    "type": {
      "name": "d20.Expression"
    }
  },
  "SimpleRollResult.consolidated()": {
    "desc": "Gets the most simplified version of the roll string. Consolidates totals and damage types together.\n\nNote that this modifies the result expression in place!",
    "url": "aliasing.api.functions.SimpleRollResult.consolidated",
    "syntax": ">>> result = vroll(\\\"3d6[fire]+1d4[cold]\\\")\n>>> str(result)\n'3d6 (3, 3, 2) [fire] + 1d4 (2) [cold] = `10`'\n>>> result.consolidated()\n'8 [fire] + 2 [cold]'",
    "returns": {
      "type": "str"
    }
  },
  "argparse(args)": {
    "desc": "Parses arguments.",
    "url": "utils.argparser.argparse",
    "param": [
      {
        "name": "args",
        "type": [
          "str",
          "iterable"
        ],
        "desc": "A list of arguments to parse"
      }
    ],
    "returns": {
      "type": "ParsedArguments",
      "desc": "The parsed arguments."
    },
    "syntax": ">>> args = argparse(\\\"adv -rr 2 -b 1d4[bless]\\\")\n>>> args.adv()\n1\n>>> args.last('rr')\n'2'\n>>> args.get('b')\n['1d4[bless]']"
  },
  "argparse(args).add_context(context, args)": {
    "desc": "Adds contextual parsed arguments (arguments that only apply in a given context)",
    "url": "utils.argparser.ParsedArguments.add_context",
    "alias": "argcontext",
    "param": [
      {
        "name": "context",
        "type": [
          "str"
        ],
        "desc": "The context to add arguments to."
      },
      {
        "name": "args",
        "type": [
          "ParsedArguments"
        ],
        "desc": "The arguments to add."
      }
    ]
  },
  "argparse(args).adv(eadv=False, boolwise=False, ephem=False, custom: dict = None)": {
    "desc": "Determines whether to roll with advantage, disadvantage, Elven Accuracy, or no special effect.",
    "url": "utils.argparser.ParsedArguments.adv",
    "param": [
      {
        "name": "eadv",
        "type": [
          "bool"
        ],
        "desc": "Whether to parse for elven accuracy."
      },
      {
        "name": "boolwise",
        "type": [
          "bool"
        ],
        "desc": "Whether to return an integer or tribool representation."
      },
      {
        "name": "ephem",
        "type": [
          "bool"
        ],
        "desc": "Whether to return an ephemeral argument if such exists."
      },
      {
        "name": "custom",
        "type": [
          "dict"
        ],
        "desc": "Dictionary of custom values to parse for. There should be a key for each value you want to overwrite. `custom={'adv': 'custom_adv'}` would allow you to parse for advantage if the `custom_adv` argument is found."
      }
    ],
    "returns": {
      "type": "int or bool",
      "desc": "`-1` or False for dis, `0` or None for normal, `1` or True for adv, `2` for ea"
    },
    "syntax": ">>> args = argparse(\\\"adv -d 1d10 sdis ea\\\")\n>>> args.adv() # Checks for adv and dis\n1\n>>> args.adv(eadv=True) # Checks for adv, dis, and ea\n2\n>>> args.adv(boolwise=True) # Returns True, False, or None instead of integers\nTrue\n>>> args.adv(custom={'adv':'sadv', 'dis':'sdis'}) # Customize which args it looks for\n-1"
  },
  "argparse(args).get(arg, default=None, type_=<class 'str'>, ephem=False)": {
    "desc": "Gets a list of all values of an argument.",
    "url": "utils.argparser.ParsedArguments.get",
    "param": [
      {
        "name": "arg",
        "type": [
          "str"
        ],
        "desc": "The name of the arg to get."
      },
      {
        "name": "default",
        "type": [
          "any"
        ],
        "desc": "The default value to return if the arg is not found. Not cast to type."
      },
      {
        "name": "type",
        "type": [
          "type"
        ],
        "desc": "The type that each value in the list should be returned as."
      },
      {
        "name": "ephem",
        "type": [
          "bool"
        ],
        "desc": "Whether to add applicable ephemeral arguments to the returned list."
      }
    ],
    "returns": {
      "type": "list",
      "desc": "The relevant argument list."
    }
  },
  "argparse(args).ignore(arg)": {
    "desc": "Removes any instances of an argument from the result in all contexts (ephemeral included).",
    "url": "utils.argparser.ParsedArguments.ignore",
    "param": [
      {
        "name": "arg",
        "type": [
          "str"
        ],
        "desc": "The argument to ignore."
      }
    ]
  },
  "argparse(args).join(arg, connector: str, default=None, ephem=False)": {
    "desc": "Returns a str formed from all of one arg, joined by a connector.",
    "url": "utils.argparser.ParsedArguments.join",
    "param": [
      {
        "name": "arg",
        "type": [
          "str"
        ],
        "desc": "The arg to join."
      },
      {
        "name": "connector",
        "type": [
          "str"
        ],
        "desc": "What to join the arg by."
      },
      {
        "name": "default",
        "type": [
          "any"
        ],
        "desc": "What to return if the arg does not exist."
      },
      {
        "name": "ephem",
        "type": [
          "bool"
        ],
        "desc": "Whether to return an ephemeral argument if such exists."
      }
    ],
    "returns": {
      "type": "str or default"
    }
  },
  "argparse(args).last(arg, default=None, type_: type = <class 'str'>, ephem=False)": {
    "desc": "Gets the last value of an arg.",
    "url": "utils.argparser.ParsedArguments.last",
    "param": [
      {
        "name": "arg",
        "type": [
          "str"
        ],
        "desc": "The name of the arg to get."
      },
      {
        "name": "default",
        "type": [
          "any"
        ],
        "desc": "The default value to return if the arg is not found. Not cast to type."
      },
      {
        "name": "type",
        "type": [
          "type"
        ],
        "desc": "The type that the arg should be returned as."
      },
      {
        "name": "ephem",
        "type": [
          "bool"
        ],
        "desc": "Whether to return an ephemeral argument if such exists."
      }
    ],
    "raises": {
      "name": "InvalidArgument",
      "desc": "If the arg cannot be cast to the type"
    },
    "returns": {
      "type": "The relevant argument."
    }
  },
  "argparse(args).set_context(context)": {
    "desc": "Sets the current argument parsing context.",
    "url": "utils.argparser.ParsedArguments.set_context",
    "alias": "argcontext",
    "param": [
      {
        "name": "context",
        "type": [
          "str"
        ],
        "desc": "Any hashable context."
      }
    ]
  },
  "argparse(args).update(new)": {
    "desc": "Updates the arguments in this argument list from a dict.",
    "url": "utils.argparser.ParsedArguments.update",
    "param": [
      {
        "name": "new",
        "type": [
          "dict[str, str] or dict[str, list[str]]"
        ],
        "desc": "The new values for each argument."
      }
    ]
  },
  "argparse(args).update_nx(new)": {
    "desc": "Like `.update()`, but only fills in arguments that were not already parsed. Ignores the argument if the value is None.",
    "url": "utils.argparser.ParsedArguments.update_nx",
    "param": [
      {
        "name": "new",
        "type": [
          "dict[str, str] or dict[str, list[str]] or dict[str, None]"
        ],
        "desc": "The new values for each argument."
      }
    ]
  },
  "ctx": {
    "desc": "The context the alias was invoked in. See [AliasContext](https://avrae.readthedocs.io/en/latest/aliasing/api.html#aliasing.api.context.AliasContext) for more details.\n\nNote that this is an automatically bound name and not a function.",
    "url": "ctx",
    "type": {
      "name": "AliasContext"
    },
    "syntax": ">>> ctx\n<AliasContext guild=Avrae Development channel=alias-testing author=Croebh#5603 prefix=! alias=test>\n>>> ctx.prefix\n\\\"!\\\" "
  },
  "ctx.alias": {
    "desc": "The command used to run the alias.",
    "url": "aliasing.api.context.AliasContext.alias",
    "returns": {
      "type": "str"
    }
  },
  "ctx.prefix": {
    "desc": "The prefix used to run the alias.",
    "url": "aliasing.api.context.AliasContext.prefix",
    "returns": {
      "type": "str"
    }
  },
  "ctx.guild": {
    "desc": "The discord guild (server) the alias was run in, or None if the alias was run in DMs.",
    "url": "aliasing.api.context.AliasContext.guild",
    "returns": {
      "type": "AliasGuild or None"
    }
  },
  "ctx.guild.id": {
    "desc": "The ID of the guild.",
    "url": "aliasing.api.context.AliasGuild.id",
    "returns": {
      "type": "int"
    }
  },
  "ctx.guild.name": {
    "desc": "The name of the guild.",
    "url": "aliasing.api.context.AliasGuild.name",
    "returns": {
      "type": "str"
    }
  },
  "ctx.channel": {
    "desc": "The channel the alias was run in.",
    "url": "aliasing.api.context.AliasContext.channel",
    "returns": {
      "type": "AliasChannel"
    }
  },
  "ctx.channel.id": {
    "desc": "The ID of the channel.",
    "url": "aliasing.api.context.AliasChannel.id",
    "returns": {
      "type": "int"
    }
  },
  "ctx.channel.name": {
    "desc": "The name of the channel, not including the preceding hash (#).",
    "url": "aliasing.api.context.AliasChannel.name",
    "returns": {
      "type": "str"
    }
  },
  "ctx.channel.parent": {
    "desc": "If this channel is a thread, the thread’s parent channel, or None otherwise.",
    "url": "aliasing.api.context.AliasChannel.parent",
    "returns": {
      "type": "AliasChannel"
    }
  },
  "ctx.channel.topic": {
    "desc": "The channel topic.",
    "url": "aliasing.api.context.AliasChannel.topic",
    "returns": {
      "type": "str"
    }
  },
  "ctx.channel.category": {
    "desc": "The category of the channel the alias was run in.",
    "url": "aliasing.api.context.AliasChannel.category",
    "returns": {
      "type": "AliasCategory"
    }
  },
  "ctx.channel.category.id": {
    "desc": "The ID of the category.",
    "url": "aliasing.api.context.AliasCategory.id",
    "returns": {
      "type": "int"
    }
  },
  "ctx.channel.category.name": {
    "desc": "The name of the category.",
    "url": "aliasing.api.context.AliasCategory.name",
    "returns": {
      "type": "str"
    }
  },
  "ctx.author": {
    "desc": "The user that ran the alias.",
    "url": "aliasing.api.context.AliasContext.author",
    "returns": {
      "type": "AliasAuthor"
    }
  },
  "ctx.author.discriminator": {
    "desc": "The user’s discriminator (number after the hash).",
    "url": "aliasing.api.context.AliasAuthor.discriminator",
    "returns": {
      "type": "str"
    }
  },
  "ctx.author.display_name": {
    "desc": "The user’s display name - nickname if applicable, otherwise same as their name.",
    "url": "aliasing.api.context.AliasAuthor.display_name",
    "returns": {
      "type": "str"
    }
  },
  "ctx.author.id": {
    "desc": "The user’s ID.",
    "url": "aliasing.api.context.AliasAuthor.id",
    "returns": {
      "type": "int"
    }
  },
  "ctx.author.name": {
    "desc": "The user’s username (not including the discriminator).",
    "url": "aliasing.api.context.AliasAuthor.name",
    "returns": {
      "type": "str"
    }
  },
  "ctx.message_id": {
    "desc": "The ID of the message the alias was invoked with.",
    "url": "aliasing.api.context.message_id",
    "returns": {
      "type": "int"
    }
  },
  "character()": {
    "desc": "The character’s actions. These do not include attacks - see the `attacks` property.",
    "url": "aliasing.evaluators.ScriptingEvaluator.character",
    "returns": {
      "type": "AliasCharacter",
      "desc": "The active character."
    },
    "syntax": ">>> char = character()\n>>> char.sheet_type\n\\\"beyond\\\"\n>>> str(char)\n<AliasStatBlock name=Croebh>"
  },
  "character().ac": {
    "desc": "The armor class of the creature.",
    "url": "aliasing.api.character.AliasCharacter.ac",
    "returns": {
      "type": "int or None"
    }
  },
  "character().actions": {
    "desc": "Returns the active character if one is. Otherwise, raises a `FunctionRequiresCharacter` error.",
    "url": "aliasing.evaluators.ScriptingEvaluator.AliasCharacter.actions",
    "returns": {
      "type": "list[AliasAction]"
    }
  },
  "character().attacks": {
    "desc": "The attacks of the creature.",
    "url": "aliasing.api.character.AliasCharacter.attacks",
    "returns": {
      "type": "AliasAttackList"
    }
  },
  "character().background": {
    "desc": "Gets the character's background.",
    "url": "aliasing.api.character.AliasCharacter.background",
    "returns": {
      "type": "str or None"
    }
  },
  "character().cc(name)": {
    "desc": "Gets the AliasCustomCounter with the name name",
    "url": "aliasing.api.character.AliasCharacter.cc",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the custom counter to get."
      }
    ],
    "returns": {
      "type": "AliasCustomCounter",
      "desc": "The custom counter"
    },
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    }
  },
  "character().cc_exists(name)": {
    "desc": "Returns whether a custom counter exists.",
    "url": "aliasing.api.character.AliasCharacter.cc_exists",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the custom counter to check."
      }
    ],
    "returns": {
      "type": "bool",
      "desc": "Whether the counter exists."
    }
  },
  "character().cc_str(name)": {
    "desc": "Returns a string representing a custom counter.",
    "url": "aliasing.api.character.AliasCharacter.cc_str",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the custom counter to get."
      }
    ],
    "returns": {
      "type": "str",
      "desc": "A string representing the current value, maximum, and minimum of the counter."
    },
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    },
    "syntax": ">>> cc_str(\\\"Ki\\\")\n'11/17'\n>>> cc_str(\\\"Bardic Inspiration\\\")\n'◉◉◉〇〇'"
  },
  "character().create_cc(name: str, minVal: str = None, maxVal: str = None, reset: str = None, dispType: str = None, reset_to: str = None, reset_by: str = None, title: str = None, desc: str = None, initial_value: str = None)": {
    "desc": "Creates a custom counter. If a counter with the same name already exists, it will replace it.",
    "url": "aliasing.api.character.AliasCharacter.create_cc",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the counter to create."
      },
      {
        "name": "minVal",
        "type": [
          "str"
        ],
        "desc": "The minimum value of the counter. Supports Cvar Table parsing."
      },
      {
        "name": "maxVal",
        "type": [
          "str"
        ],
        "desc": "The maximum value of the counter. Supports Cvar Table parsing."
      },
      {
        "name": "reset",
        "type": [
          "str"
        ],
        "desc": "One of 'short', 'long', 'hp', 'none', or None."
      },
      {
        "name": "dispType",
        "type": [
          "str"
        ],
        "desc": "Either None or 'bubble'."
      },
      {
        "name": "reset_to",
        "type": [
          "str"
        ],
        "desc": "The value the counter should reset to. Supports cvar parsing."
      },
      {
        "name": "reset_by",
        "type": [
          "str"
        ],
        "desc": "How much the counter should change by on a reset. Supports dice but not cvars."
      },
      {
        "name": "title",
        "type": [
          "str"
        ],
        "desc": "The title of the counter."
      },
      {
        "name": "desc",
        "type": [
          "str"
        ],
        "desc": "The description of the counter."
      },
      {
        "name": "initial_value",
        "type": [
          "str"
        ],
        "desc": "The initial value of the counter."
      }
    ],
    "returns": {
      "type": "AliasCustomCounter",
      "desc": "The newly created counter."
    }
  },
  "character().create_cc_nx(name: str, minVal: str = None, maxVal: str = None, reset: str = None, dispType: str = None, reset_to: str = None, reset_by: str = None, title: str = None, desc: str = None, initial_value: str = None)": {
    "desc": "Creates a custom counter if one with the given name does not already exist. Equivalent to:",
    "url": "aliasing.api.character.AliasCharacter.create_cc_nx",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the counter to create."
      },
      {
        "name": "minVal",
        "type": [
          "str"
        ],
        "desc": "The minimum value of the counter. Supports Cvar Table parsing."
      },
      {
        "name": "maxVal",
        "type": [
          "str"
        ],
        "desc": "The maximum value of the counter. Supports Cvar Table parsing."
      },
      {
        "name": "reset",
        "type": [
          "str"
        ],
        "desc": "One of 'short', 'long', 'hp', 'none', or None."
      },
      {
        "name": "dispType",
        "type": [
          "str"
        ],
        "desc": "Either None or 'bubble'."
      },
      {
        "name": "reset_to",
        "type": [
          "str"
        ],
        "desc": "The value the counter should reset to. Supports cvar parsing."
      },
      {
        "name": "reset_by",
        "type": [
          "str"
        ],
        "desc": "How much the counter should change by on a reset. Supports dice but not cvars."
      },
      {
        "name": "title",
        "type": [
          "str"
        ],
        "desc": "The title of the counter."
      },
      {
        "name": "desc",
        "type": [
          "str"
        ],
        "desc": "The description of the counter."
      },
      {
        "name": "initial_value",
        "type": [
          "str"
        ],
        "desc": "The initial value of the counter."
      }
    ],
    "returns": {
      "type": "AliasCustomCounter",
      "desc": "The newly created counter."
    }
  },
  "character().edit_cc(name: str, minVal: str = sentinel, maxVal: str = sentinel, reset: str = sentinel, dispType: str = sentinel, reset_to: str = sentinel, reset_by: str = sentinel, title: str = sentinel, desc: str = sentinel, new_name: str = None)": {
    "desc": "Edits an existing custom counter.\n\nPass `None` to remove an argument entirely. Will clamp counter value to new limits if needed.",
    "url": "aliasing.api.character.AliasCharacter.edit_cc",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the counter to edit."
      },
      {
        "name": "minVal",
        "type": [
          "str"
        ],
        "desc": "The minimum value of the counter. Supports Cvar Table parsing."
      },
      {
        "name": "maxVal",
        "type": [
          "str"
        ],
        "desc": "The maximum value of the counter. Supports Cvar Table parsing."
      },
      {
        "name": "reset",
        "type": [
          "str"
        ],
        "desc": "One of 'short', 'long', 'hp', 'none', or None."
      },
      {
        "name": "dispType",
        "type": [
          "str"
        ],
        "desc": "Either None or 'bubble'."
      },
      {
        "name": "reset_to",
        "type": [
          "str"
        ],
        "desc": "The value the counter should reset to. Supports cvar parsing."
      },
      {
        "name": "reset_by",
        "type": [
          "str"
        ],
        "desc": "How much the counter should change by on a reset. Supports dice but not cvars."
      },
      {
        "name": "title",
        "type": [
          "str"
        ],
        "desc": "The title of the counter."
      },
      {
        "name": "desc",
        "type": [
          "str"
        ],
        "desc": "The description of the counter."
      },
      {
        "name": "new_name",
        "type": [
          "str"
        ],
        "desc": "The new name of the counter."
      }
    ],
    "returns": {
      "type": "AliasCustomCounter",
      "desc": "The edit counter."
    },
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    }
  },
  "character().csettings": {
    "desc": "Gets a copy of the character’s settings dict.",
    "url": "aliasing.api.character.AliasCharacter.csettings",
    "returns": {
      "type": "dict"
    }
  },
  "character().creature_type": {
    "desc": "The creature type of the creature. Will return None for players or creatures with no creature type.",
    "url": "aliasing.api.character.AliasCharacter.creature_type",
    "returns": {
      "type": "str or None"
    }
  },
  "character().consumables": {
    "desc": "Returns a list of custom counters on the character.",
    "url": "aliasing.api.character.AliasCharacter.consumables",
    "returns": {
      "type": "list[AliasCustomCounter]"
    }
  },
  "character().delete_cc(name)": {
    "desc": "Deletes a custom counter.\n\n**Note:** This method does not unbind the name in the current runtime.",
    "url": "aliasing.api.character.AliasCharacter.delete_cc",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the custom counter to delete."
      }
    ],
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    }
  },
  "character().delete_cvar(name)": {
    "desc": "Deletes a custom character variable. Does nothing if the cvar does not exist.",
    "url": "aliasing.api.character.AliasCharacter.delete_cvar",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the variable to delete."
      }
    ]
  },
  "character().owner": {
    "desc": "Returns the id of this character's owner.",
    "url": "aliasing.api.character.AliasCharacter.owner",
    "returns": {
      "type": "int"
    }
  },
  "character().upstream": {
    "desc": "Returns the upstream key for this character.",
    "url": "aliasing.api.character.AliasCharacter.upstream",
    "returns": {
      "type": "str"
    }
  },
  "character().sheet_type": {
    "desc": "Returns the sheet type of this character (beyond, dicecloud, google).",
    "url": "aliasing.api.character.AliasCharacter.sheet_type",
    "returns": {
      "type": "str"
    }
  },
  "character().get_cc(name)": {
    "desc": "Gets the value of a custom counter.",
    "url": "aliasing.api.character.AliasCharacter.get_cc",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the custom counter to get."
      }
    ],
    "returns": {
      "type": "int",
      "desc": "The current value of the counter."
    },
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    }
  },
  "character().get_cc_max(name)": {
    "desc": "Gets the maximum value of a custom counter.",
    "url": "aliasing.api.character.AliasCharacter.get_cc_max",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the custom counter maximum to get."
      }
    ],
    "returns": {
      "type": "int",
      "desc": "The maximum value of the counter. If a counter has no maximum, it will return INT_MAX (2^31-1)."
    },
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    }
  },
  "character().get_cc_min(name)": {
    "desc": "Gets the minimum value of a custom counter.",
    "url": "aliasing.api.character.AliasCharacter.get_cc_min",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the custom counter minimum to get."
      }
    ],
    "returns": {
      "type": "int",
      "desc": "The minimum value of the counter. If a counter has no minimum, it will return INT_MIN (-2^31)."
    },
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    }
  },
  "character().hp": {
    "desc": "The current HP of the creature.",
    "url": "aliasing.api.character.AliasCharacter.hp",
    "returns": {
      "type": "int or None"
    }
  },
  "character().hp_str()": {
    "desc": "Returns a string describing the creature’s current, max, and temp HP.",
    "url": "aliasing.api.character.AliasCharacter.hp_str",
    "returns": {
      "type": "str"
    }
  },
  "character().levels": {
    "desc": "The levels of the creature.",
    "url": "aliasing.api.character.AliasCharacter.levels",
    "returns": {
      "type": "AliasLevels"
    }
  },
  "character().max_hp": {
    "desc": "The maximum HP of the creature.",
    "url": "aliasing.api.character.AliasCharacter.max_hp",
    "returns": {
      "type": "int or None"
    }
  },
  "character().mod_cc(name, val: int, strict=False)": {
    "desc": "Modifies the value of a custom counter. Equivalent to set_cc(name, get_cc(name) + value, strict).",
    "url": "aliasing.api.character.AliasCharacter.mod_cc",
    "returns": {
      "type": "int",
      "desc": "The cc's new value."
    },
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    }
  },
  "character().modify_hp(amount, ignore_temp=False, overflow=True)": {
    "desc": "Modifies the creature’s remaining HP by a given amount.",
    "url": "aliasing.api.character.AliasCharacter.modify_hp",
    "param": [
      {
        "name": "amount",
        "type": [
          "int"
        ],
        "desc": "The amount of HP to add/remove."
      },
      {
        "name": "ignore_temp",
        "type": [
          "bool"
        ],
        "desc": "If amount is negative, whether to damage temp HP first or ignore temp."
      },
      {
        "name": "overflow",
        "type": [
          "bool"
        ],
        "desc": "If amount is positive, whether to allow overhealing or cap at the creature’s max HP."
      }
    ]
  },
  "character().name": {
    "desc": "The name of the creature.",
    "url": "aliasing.api.character.AliasCharacter.name",
    "returns": {
      "type": "str"
    }
  },
  "character().race": {
    "desc": "Gets the character’s race.",
    "url": "aliasing.api.character.AliasCharacter.race",
    "returns": {
      "type": "str or None"
    }
  },
  "character().reset_hp()": {
    "desc": "Heals a creature to max and removes any temp HP.",
    "url": "aliasing.api.character.AliasCharacter.reset_hp"
  },
  "character().resistances": {
    "desc": "The resistances, immunities, and vulnerabilities of the creature.",
    "url": "aliasing.api.character.AliasCharacter.resistances",
    "returns": {
      "type": "AliasResistances"
    }
  },
  "character().saves": {
    "desc": "The saves of the creature.",
    "url": "aliasing.api.character.AliasCharacter.saves",
    "returns": {
      "type": "AliasSaves"
    }
  },
  "character().set_cc(name, value: int, strict=False)": {
    "desc": "Sets the value of a custom counter.",
    "url": "aliasing.api.character.AliasCharacter.set_cc",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the custom counter to set."
      },
      {
        "name": "value",
        "type": [
          "int"
        ],
        "desc": "The value to set the counter to."
      },
      {
        "name": "strict",
        "type": [
          "bool"
        ],
        "desc": "If True, will raise a CounterOutOfBounds if the new value is out of bounds, otherwise silently clips to bounds."
      }
    ],
    "returns": {
      "type": "int",
      "desc": "The cc's new value."
    },
    "raises": {
      "name": "ConsumableException",
      "desc": "If the counter does not exist."
    }
  },
  "character().cvars": {
    "desc": "Returns a dict of cvars bound on this character.",
    "url": "aliasing.api.character.AliasCharacter.cvars",
    "returns": {
      "type": "dict"
    }
  },
  "character().set_cvar(name, val: str)": {
    "desc": "Sets a custom character variable, which will be available in all scripting contexts using this character.",
    "url": "aliasing.api.character.AliasCharacter.set_cvar",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the variable to set. Must be a valid identifier and not be in the Cvar Table."
      },
      {
        "name": "value",
        "type": [
          "str"
        ],
        "desc": "The value to set it to."
      }
    ]
  },
  "character().set_cvar_nx(name, val: str)": {
    "desc": "Sets a custom character variable if it is not already set.",
    "url": "aliasing.api.character.AliasCharacter.set_cvar_nx",
    "param": [
      {
        "name": "name",
        "type": [
          "str"
        ],
        "desc": "The name of the variable to set. Must be a valid identifier and not be in the Cvar Table."
      },
      {
        "name": "value",
        "type": [
          "str"
        ],
        "desc": "The value to set it to."
      }
    ]
  },
  "character().set_hp(new_hp)": {
    "desc": "Sets the creature’s remaining HP.",
    "url": "aliasing.api.character.AliasCharacter.set_hp",
    "param": [
      {
        "name": "new_hp",
        "type": [
          "int"
        ],
        "desc": "The amount of remaining HP (a nonnegative integer)."
      }
    ]
  },
  "character().set_temp_hp(new_temp)": {
    "desc": "Sets a creature’s temp HP.",
    "url": "aliasing.api.character.AliasCharacter.set_temp_hp",
    "param": [
      {
        "name": "new_temp",
        "type": [
          "int"
        ],
        "desc": "The new temp HP (a non-negative integer)."
      }
    ]
  },
  "character().skills": {
    "desc": "The skills of the creature.",
    "url": "aliasing.api.character.AliasCharacter.skills",
    "returns": {
      "type": "AliasSkills"
    }
  },
  "character().spellbook": {
    "desc": "The creature’s spellcasting information.",
    "url": "aliasing.api.character.AliasCharacter.spellbook",
    "returns": {
      "type": "AliasSpellbook"
    }
  },
  "character().stats": {
    "desc": "The stats of the creature.",
    "url": "aliasing.api.character.AliasCharacter.stats",
    "returns": {
      "type": "AliasBaseStats"
    }
  },
  "character().temp_hp": {
    "desc": "The current temp HP of the creature.",
    "url": "aliasing.api.character.AliasCharacter.temp_hp",
    "returns": {
      "type": "int"
    }
  },
  "AliasCustomCounter.desc": {
    "url": "aliasing.api.character.AliasCustomCounter.desc",
    "desc": "Returns the cc’s description.",
    "returns": {
      "type": "str or None"
    }
  },
  "AliasCustomCounter.title": {
    "url": "aliasing.api.character.AliasCustomCounter.title",
    "desc": "Returns the cc’s title.",
    "returns": {
      "type": "str or None"
    }
  },
  "AliasCustomCounter.display_type": {
    "url": "aliasing.api.character.AliasCustomCounter.display_type",
    "desc": "Returns the cc’s display type. (None, ‘bubble’)",
    "returns": {
      "type": "str or None"
    }
  },
  "AliasCustomCounter.full_str(include_name: bool = False)": {
    "url": "aliasing.api.character.AliasCustomCounter.full_str",
    "desc": "Returns a string representing the full custom counter.",
    "params": [
      {
        "name": "include_name",
        "type": [
          "bool"
        ],
        "desc": "If the name of the counter should be included. Defaults to False."
      }
    ],
    "returns": {
      "type": "str",
      "desc": "A string representing all components of the counter."
    }
  },
  "AliasCustomCounter.max": {
    "url": "aliasing.api.character.AliasCustomCounter.max",
    "desc": "Returns the maximum value of the cc, or 2^31-1 if the cc has no max.",
    "returns": {
      "type": "int"
    }
  },
  "AliasCustomCounter.min": {
    "url": "aliasing.api.character.AliasCustomCounter.min",
    "desc": "Returns the minimum value of the cc, or -2^31 if the cc has no min.",
    "returns": {
      "type": "int"
    }
  },
  "AliasCustomCounter.name": {
    "url": "aliasing.api.character.AliasCustomCounter.name",
    "desc": "Returns the cc’s name.",
    "returns": {
      "type": "str"
    }
  },
  "AliasCustomCounter.reset()": {
    "url": "aliasing.api.character.AliasCustomCounter.reset()",
    "desc": "Resets the cc to its reset value. Errors if the cc has no reset value or no reset.\n\nThe reset value is calculated in 3 steps:\n - if the cc has a `reset_to` value, it is reset to that\n - else if the cc has a `reset_by` value, it is modified by that much\n - else the reset value is its max",
    "returns": {
      "type": "CustomCounterResetResult",
      "desc": "(new_value: `int`, old_value: `int`, target_value: `int`, delta: `str`)"
    }
  },
  "AliasCustomCounter.reset_on": {
    "url": "aliasing.api.character.AliasCustomCounter.reset_on",
    "desc": "Returns the condition on which the cc resets. (‘long’, ‘short’, ‘none’, None)",
    "returns": {
      "type": "int or None"
    }
  },
  "AliasCustomCounter.reset_to": {
    "url": "aliasing.api.character.AliasCustomCounter.reset_to",
    "desc": "Returns the value the cc resets to, if it was created with an explicit `resetto`.",
    "returns": {
      "type": "str or None"
    }
  },
  "AliasCustomCounter.reset_by": {
    "url": "aliasing.api.character.AliasCustomCounter.reset_by",
    "desc": "Returns the amount the cc changes by on a reset, if it was created with an explicit `resetby`.",
    "returns": {
      "type": "str or None"
    }
  },
  "AliasCustomCounter.set(new_value, strict=False)": {
    "url": "aliasing.api.character.AliasCustomCounter.set(new_value, strict=False)",
    "desc": "Sets the cc’s value to a new value.",
    "params": [
      {
        "name": "new_value",
        "type": [
          "int"
        ],
        "desc": "The new value to set."
      },
      {
        "name": "strict",
        "type": [
          "bool"
        ],
        "desc": "Whether to error when going out of bounds (true) or to clip silently (false)."
      }
    ],
    "returns": {
      "type": "int",
      "desc": "The cc’s new value."
    }
  },
  "AliasCustomCounter.value": {
    "url": "aliasing.api.character.AliasCustomCounter.value",
    "desc": "Returns the current value of the cc.",
    "returns": {
      "type": "int"
    }
  },
  "AliasDeathSaves.fail(num=1)": {
    "desc": "Adds one or more failed death saves.",
    "url": "aliasing.api.character.AliasDeathSaves.fail",
    "param": [
      {
        "name": "num",
        "type": [
          "int"
        ],
        "desc": "The number of failed death saves to add."
      }
    ]
  },
  "AliasDeathSaves.fails": {
    "desc": "Returns the number of failed death saves.",
    "url": "aliasing.api.character.AliasDeathSaves.fails",
    "returns": {
      "type": "int"
    }
  },
  "AliasDeathSaves.is_dead()": {
    "desc": "Returns whether or not the character is dead.",
    "url": "aliasing.api.character.AliasDeathSaves.is_dead",
    "returns": {
      "type": "bool"
    }
  },
  "AliasDeathSaves.is_stable()": {
    "desc": "Returns whether or not the character is stable.",
    "url": "aliasing.api.character.AliasDeathSaves.is_stable",
    "returns": {
      "type": "bool"
    }
  },
  "AliasDeathSaves.reset()": {
    "desc": "Resets all death saves.",
    "url": "aliasing.api.character.AliasDeathSaves.reset"
  },
  "AliasDeathSaves.succeed(num=1)": {
    "desc": "Adds one or more successful death saves.",
    "url": "aliasing.api.character.AliasDeathSaves.succeed",
    "param": [
      {
        "name": "num",
        "type": [
          "int"
        ],
        "desc": "The number of successful death saves to add."
      }
    ]
  },
  "AliasDeathSaves.successes": {
    "desc": "Returns the number of successful death saves.",
    "url": "aliasing.api.character.AliasDeathSaves.successes",
    "returns": {
      "type": "int"
    }
  },
  "AliasAction.activation_type": {
    "url": "aliasing.api.character.AliasAction.activation_type",
    "desc": "The activation type of the action (e.g. action, bonus, etc).```\nAction Type   |  Value\n--------------|--------\nAction        |  1\nNo Action     |  2\nBonus Action  |  3\nReaction      |  4\nMinute        |  6\nHour          |  7\nSpecial       |  8```",
    "returns": {
      "type": "int"
    }
  },
  "AliasAction.activation_type_name": {
    "url": "aliasing.api.character.AliasAction.activation_type_name",
    "desc": "The name of the activation type of the action. Will be one of: “ACTION”, “NO_ACTION”, “BONUS_ACTION”, “REACTION”, “MINUTE”, “HOUR”, “SPECIAL”. This list of options may expand in the future.",
    "returns": {
      "type": "str"
    }
  },
  "AliasAction.description": {
    "url": "aliasing.api.character.AliasAction.description",
    "desc": "The description of the action as it appears in a non-verbose action list.",
    "returns": {
      "type": "str"
    }
  },
  "AliasAction.name": {
    "url": "aliasing.api.character.AliasAction.name",
    "desc": "The name of the action.",
    "returns": {
      "type": "str"
    }
  },
  "AliasAction.snippet": {
    "url": "aliasing.api.character.AliasAction.snippet",
    "desc": "The description of the action as it appears in a verbose action list.",
    "returns": {
      "type": "str"
    }
  },
  "AliasBaseStats.charisma": {
    "desc": "Charisma score.",
    "url": "aliasing.api.statblock.AliasBaseStats.charisma",
    "returns": {
      "type": "int"
    }
  },
  "AliasBaseStats.constitution": {
    "desc": "Constitution score.",
    "url": "aliasing.api.statblock.AliasBaseStats.constitution",
    "returns": {
      "type": "int"
    }
  },
  "AliasBaseStats.dexterity": {
    "desc": "Dexterity score.",
    "url": "aliasing.api.statblock.AliasBaseStats.dexterity",
    "returns": {
      "type": "int"
    }
  },
  "AliasBaseStats.get_mod(stat: str)": {
    "desc": "Gets the modifier for a base stat (str, dex, con, etc). Does not take skill check bonuses into account.\nFor the skill check modifier, use `StatBlock.skills.strength` etc.",
    "url": "aliasing.api.statblock.AliasBaseStats.get_mod",
    "param": [
      {
        "name": "stat",
        "type": [
          "str"
        ],
        "desc": "The stat to get the modifier for."
      }
    ],
    "returns": {
      "type": "int"
    }
  },
  "AliasBaseStats.intelligence": {
    "desc": "Intelligence score.",
    "url": "aliasing.api.statblock.AliasBaseStats.intelligence",
    "returns": {
      "type": "int"
    }
  },
  "AliasBaseStats.prof_bonus": {
    "desc": "The proficiency bonus.",
    "url": "aliasing.api.statblock.AliasBaseStats.prof_bonus",
    "returns": {
      "type": "int"
    }
  },
  "AliasBaseStats.strength": {
    "desc": "Strength score.",
    "url": "aliasing.api.statblock.AliasBaseStats.strength",
    "returns": {
      "type": "int"
    }
  },
  "AliasBaseStats.wisdom": {
    "desc": "Wisdom score.",
    "url": "aliasing.api.statblock.AliasBaseStats.wisdom",
    "returns": {
      "type": "int"
    }
  },
  "for (cls, level) in AliasLevels:": {
    "desc": "Iterates over pairs of class names and the number of levels in that class.",
    "url": "aliasing.api.statblock.AliasLevels",
    "type": {
      "name": "Iterable[tuple[str, int]]"
    }
  },
  "AliasLevels.get(cls_name, default=0)": {
    "desc": "Gets the levels in a given class, or default if there are none.",
    "url": "aliasing.api.statblock.AliasLevels.get",
    "param": [
      {
        "name": "cls_name",
        "type": [
          "str"
        ],
        "desc": "The name of the class to get the levels of."
      },
      {
        "name": "default",
        "type": [
          "int"
        ],
        "desc": "What to return if the statblock does not have levels in the given class."
      }
    ],
    "returns": {
      "type": "int"
    }
  },
  "AliasLevels.total_level": {
    "desc": "The total level.",
    "url": "aliasing.api.statblock.AliasLevels.total_level",
    "returns": {
      "type": "int"
    }
  },
  "str(AliasAttackList)": {
    "desc": "Returns a string representation of all attacks in this attack list.",
    "url": "aliasing.api.statblock.AliasAttackList.str",
    "type": {
      "name": "str"
    }
  },
  "len(AliasAttackList)": {
    "desc": "Returns the number of attacks in this attack list.",
    "url": "aliasing.api.statblock.AliasAttackList.len",
    "type": {
      "name": "int"
    }
  },
  "for attack in AliasAttackList:": {
    "desc": "Iterates over attacks in this attack list.",
    "url": "aliasattacklist",
    "type": {
      "name": "Iterable[AliasAttack]"
    }
  },
  "AliasAttackList[i]": {
    "desc": "Gets the i-th indexed attack.",
    "url": "aliasattacklist",
    "type": {
      "name": "AliasAttack"
    }
  },
  "str(AliasAttack)": {
    "desc": "Returns a string representation of this attack.",
    "url": "aliasing.api.statblock.AliasAttack.str",
    "type": {
      "name": "str"
    }
  },
  "AliasAttack.name": {
    "desc": "The name of the attack.",
    "url": "aliasing.api.statblock.AliasAttack.name",
    "returns": {
      "type": "str"
    }
  },
  "AliasAttack.proper": {
    "desc": "Whether or not this attack is a proper noun.",
    "url": "aliasing.api.statblock.AliasAttack.proper",
    "returns": {
      "type": "bool"
    }
  },
  "AliasAttack.raw": {
    "desc": "A dict representing the raw value of this attack.",
    "url": "aliasing.api.statblock.AliasAttack.raw",
    "returns": {
      "type": "dict"
    }
  },
  "AliasAttack.verb": {
    "desc": "The custom verb used for this attack, if applicable.",
    "url": "aliasing.api.statblock.AliasAttack.verb",
    "returns": {
      "type": "str or None"
    }
  },
  "AliasSkill.adv": {
    "desc": "The guaranteed advantage or disadvantage on this skill modifier. True = adv, False = dis, None = normal.",
    "url": "aliasing.api.statblock.AliasSkill.adv",
    "returns": {
      "type": "bool or None"
    }
  },
  "AliasSkill.bonus": {
    "desc": "The miscellaneous bonus to the skill modifier.",
    "url": "aliasing.api.statblock.AliasSkill.bonus",
    "returns": {
      "type": "int"
    }
  },
  "AliasSkill.d20(base_adv=None, reroll=None, min_val=None, mod_override=None)": {
    "desc": "Gets a dice string representing the roll for this skill.",
    "url": "aliasing.api.statblock.AliasSkill.d20",
    "param": [
      {
        "name": "base_adv",
        "type": [
          "bool"
        ],
        "desc": "Whether this roll should be made at adv (True), dis (False), or normally (None)."
      },
      {
        "name": "reroll",
        "type": [
          "int"
        ],
        "desc": "If the roll lands on this number, reroll it once (Halfling Luck)."
      },
      {
        "name": "min_val",
        "type": [
          "int"
        ],
        "desc": "The minimum value of the dice roll (Reliable Talent, Glibness)."
      },
      {
        "name": "mod_override",
        "type": [
          "int"
        ],
        "desc": "Overrides the skill modifier."
      }
    ],
    "returns": {
      "type": "str"
    }
  },
  "AliasSkill.prof": {
    "desc": "The proficiency multiplier in this skill. 0 = no proficiency, 0.5 = JoAT, 1 = proficiency, 2 = expertise.",
    "url": "aliasing.api.statblock.AliasSkill.prof",
    "returns": {
      "type": "float or int"
    }
  },
  "AliasSkill.value": {
    "desc": "The final modifier. Generally, value = (base stat mod) + (profBonus) * prof + bonus.",
    "url": "aliasing.api.statblock.AliasSkill.value",
    "returns": {
      "type": "int"
    }
  },
  "AliasSkills.<Skill>": {
    "desc": "The skill modifier for a given skill. Valid skills: `acrobatics`, `animalHandling`, `arcana`, `athletics`, `deception`, `history`, `initiative`, `insight`, `intimidation`, `investigation`, `medicine`, `nature`, `perception`, `performance`, `persuasion`, `religion`, `sleightOfHand`, `stealth`, `survival`, `strength`, `dexterity`, `constitution`, `intelligence`, `wisdom`, and `charisma`",
    "url": "aliasing.api.statblock.AliasSkills",
    "type": {
      "name": "AliasSkill"
    }
  },
  "for (save_name, skill) in AliasSaves:": {
    "desc": "Iterates over pairs of save names and corresponding save.",
    "url": "aliasing.api.statblock.AliasSaves",
    "type": {
      "name": "Iterable[tuple[str, AliasSkill]]"
    }
  },
  "AliasSaves.get(base_stat)": {
    "desc": "Gets the save skill for a given stat (str, dex, etc).",
    "url": "aliasing.api.statblock.AliasSaves.get",
    "param": [
      {
        "name": "base_stat",
        "type": [
          "str"
        ],
        "desc": "The stat to get the save for."
      }
    ],
    "returns": {
      "type": "AliasSkill"
    }
  },
  "AliasResistances.immune": {
    "desc": "A list of damage types that the stat block is immune to.",
    "url": "aliasing.api.statblock.AliasResistances.immune",
    "returns": {
      "type": "list[Resistance]"
    }
  },
  "AliasResistances.neutral": {
    "desc": "A list of damage types that the stat block ignores in damage calculations. (i.e. will not handle resistances/ vulnerabilities/immunities)",
    "url": "aliasing.api.statblock.AliasResistances.neutral",
    "returns": {
      "type": "list[Resistance]"
    }
  },
  "AliasResistances.resist": {
    "desc": "A list of damage types that the stat block is resistant to.",
    "url": "aliasing.api.statblock.AliasResistances.resist",
    "returns": {
      "type": "list[Resistance]"
    }
  },
  "AliasResistances.vuln": {
    "desc": "A list of damage types that the stat block is vulnerable to.",
    "url": "aliasing.api.statblock.AliasResistances.vuln",
    "returns": {
      "type": "list[Resistance]"
    }
  },
  "Resistance": {
    "desc": "Represents a conditional resistance to a damage type.\nOnly applied to a type token set T if `dtype ∈ T ∧ ¬(unless ∩ T) ∧ only ⊂ T`.\nNote: transforms all damage types given to lowercase.",
    "url": "cogs5e.models.sheet.resistance.Resistance"
  },
  "Resistance.dtype": {
    "desc": "The damage type.",
    "url": "Resistance.dtype",
    "type": {
      "name": "str"
    }
  },
  "Resistance.unless": {
    "desc": "A set of tokens that if present, this resistance will not apply.",
    "url": "Resistance.unless",
    "type": {
      "name": "set[str]"
    }
  },
  "Resistance.only": {
    "desc": "A set of tokens that unless present, this resistance will not apply.",
    "url": "Resistance.only",
    "type": {
      "name": "set[str]"
    }
  },
  "Resistance.applies_to(tokens)": {
    "desc": "Note that tokens should be a set of lowercase strings.",
    "url": "Resistance.applies_to",
    "param": [
      {
        "name": "tokens",
        "type": [
          "set[str]"
        ],
        "desc": "A set of strings to test against."
      }
    ],
    "returns": {
      "type": "bool"
    }
  },
  "Resistance.applies_to_str(dtype)": {
    "desc": "Returns whether or not this resistance is applicable to a damage type.",
    "url": "Resistance.applies_to_str",
    "param": [
      {
        "name": "dtype",
        "type": [
          "str"
        ],
        "desc": "The damage type to test."
      }
    ],
    "returns": {
      "type": "bool"
    }
  },
  "Resistance.is_complex": {
    "desc": "Whether or not the resistance has some more complex conditional beyond just a dtype.",
    "url": "Resistance.is_complex",
    "returns": {
      "type": "bool"
    }
  },
  "spell in AliasSpellbook": {
    "desc": "Returns whether the spell named spell (str) is known.",
    "url": "aliasing.api.statblock.AliasSpellbook",
    "type": {
      "name": "bool"
    }
  },
  "AliasSpellbook.can_cast(spell, level)": {
    "desc": "Returns whether or not the given spell can currently be cast at the given level. Does not check to see what level that spell is, only if its in the creatures spellbook and they have the resources to cast it.",
    "url": "aliasing.api.statblock.AliasSpellbook.can_cast",
    "param": [
      {
        "name": "spell",
        "type": [
          "str"
        ],
        "desc": "The name of the spell."
      },
      {
        "name": "level",
        "type": [
          "int"
        ],
        "desc": "The level the spell is being cast at."
      }
    ],
    "returns": {
      "type": "bool"
    }
  },
  "AliasSpellbook.cast(spell, level)": {
    "desc": "Uses all resources to cast a given spell at a given level.",
    "url": "aliasing.api.statblock.AliasSpellbook.cast",
    "param": [
      {
        "name": "spell",
        "type": [
          "str"
        ],
        "desc": "The name of the spell."
      },
      {
        "name": "level",
        "type": [
          "int"
        ],
        "desc": "The level the spell is being cast at."
      }
    ]
  },
  "AliasSpellbook.caster_level": {
    "desc": "The caster’s caster level.",
    "url": "aliasing.api.statblock.AliasSpellbook.caster_level",
    "returns": {
      "type": "int"
    }
  },
  "AliasSpellbook.dc": {
    "desc": "The spellcasting DC.",
    "url": "aliasing.api.statblock.AliasSpellbook.dc",
    "returns": {
      "type": "int"
    }
  },
  "AliasSpellbook.max_pact_slots": {
    "desc": "The maximum number of pact slots the spellcaster has remaining. If the spellcaster has no pact slots, returns `None`.\n\n**Note:** Only D&D Beyond character sheets support the explicit distinction between pact and non-pact slots.",
    "url": "aliasing.api.statblock.AliasSpellbook.max_pact_slots",
    "returns": {
      "type": "int or None"
    }
  },
  "AliasSpellbook.num_pact_slots": {
    "desc": "The number of pact slots the spellcaster has remaining. If the spellcaster has no pact slots, returns `None`.\n\n**Note:** Only D&D Beyond character sheets support the explicit distinction between pact and non-pact slots.",
    "url": "aliasing.api.statblock.AliasSpellbook.num_pact_slots",
    "returns": {
      "type": "int or None"
    }
  },
  "AliasSpellbook.pact_slot_level": {
    "desc": "The spellcaster’s pact slot level. If the spellcaster has no pact slots, returns `None`.\n\n**Note:** Only D&D Beyond character sheets support the explicit distinction between pact and non-pact slots.",
    "url": "aliasing.api.statblock.AliasSpellbook.pact_slot_level",
    "returns": {
      "type": "int or None"
    }
  },
  "AliasSpellbook.get_max_slots(level)": {
    "desc": "Gets the maximum number of level level spell slots available.",
    "url": "aliasing.api.statblock.AliasSpellbook.get_max_slots",
    "param": [
      {
        "name": "level",
        "type": [
          "int"
        ],
        "desc": "The spell level [1..9]."
      }
    ],
    "returns": {
      "type": "int",
      "desc": "The maximum number of spell slots."
    }
  },
  "AliasSpellbook.get_slots(level)": {
    "desc": "Gets the remaining number of slots of a given level. Always returns 1 if level is 0.",
    "url": "aliasing.api.statblock.AliasSpellbook.get_slots",
    "param": [
      {
        "name": "level",
        "type": [
          "int"
        ],
        "desc": "The spell level to get the remaining slots of."
      }
    ],
    "returns": {
      "type": "int",
      "desc": "The number of slots remaining."
    }
  },
  "AliasSpellbook.remaining_casts_of(spell, level)": {
    "desc": "Gets a string representing the remaining casts of a given spell at a given level.",
    "url": "aliasing.api.statblock.AliasSpellbook.remaining_casts_of",
    "param": [
      {
        "name": "spell",
        "type": [
          "str"
        ],
        "desc": "The name of the spell (case-sensitive)."
      },
      {
        "name": "level",
        "type": [
          "int"
        ],
        "desc": "The level the spell is being cast at."
      }
    ],
    "returns": {
      "type": "str"
    }
  },
  "AliasSpellbook.reset_pact_slots()": {
    "desc": "Resets the number of remaining pact slots to the max, leaving non-pact slots untouched.",
    "url": "aliasing.api.statblock.AliasSpellbook.reset_pact_slots"
  },
  "AliasSpellbook.reset_slots()": {
    "desc": "Resets the number of remaining spell slots of all levels to the max.",
    "url": "aliasing.api.statblock.AliasSpellbook.reset_slots"
  },
  "AliasSpellbook.sab": {
    "desc": "The spell attack bonus.",
    "url": "aliasing.api.statblock.AliasSpellbook.sab",
    "returns": {
      "type": "int"
    }
  },
  "AliasSpellbook.set_slots(level, value)": {
    "desc": "Sets the remaining number of spell slots of a given level.",
    "url": "aliasing.api.statblock.AliasSpellbook.set_slots",
    "param": [
      {
        "name": "level",
        "type": [
          "int"
        ],
        "desc": "The spell level to set [1..9]."
      },
      {
        "name": "value",
        "type": [
          "int"
        ],
        "desc": "The remaining number of slots."
      }
    ]
  },
  "AliasSpellbook.slots_str(level)": {
    "desc": "Returns a string representing how many slots of a level a caster has.",
    "url": "aliasing.api.statblock.AliasSpellbook.slots_str",
    "param": [
      {
        "name": "level",
        "type": [
          "int"
        ],
        "desc": "The level of spell slot to return."
      }
    ],
    "returns": {
      "type": "str",
      "desc": "A string representing the caster’s remaining spell slots."
    }
  },
  "AliasSpellbook.spell_mod": {
    "desc": "The spellcasting modifier.",
    "url": "aliasing.api.statblock.AliasSpellbook.spell_mod",
    "returns": {
      "type": "int"
    }
  },
  "AliasSpellbook.spells": {
    "desc": "The list of spells in this spellbook.",
    "url": "aliasing.api.statblock.AliasSpellbook.spells",
    "returns": {
      "type": "list[AliasSpellbookSpell]"
    }
  },
  "AliasSpellbook.use_slot(level)": {
    "desc": "Uses one spell slot of a given level. Equivalent to set_slots(level, get_slots(level) - 1).",
    "url": "aliasing.api.statblock.AliasSpellbook.use_slot",
    "param": [
      {
        "name": "level",
        "type": [
          "int"
        ],
        "desc": "The level of spell slot to use."
      }
    ]
  },
  "AliasSpellbookSpell.dc": {
    "url": "aliasing.api.statblock.AliasSpellbookSpell.dc",
    "desc": "The spell’s overridden DC. None if this spell uses the default caster DC.",
    "returns": {
      "type": "int or None"
    }
  },
  "AliasSpellbookSpell.mod": {
    "url": "aliasing.api.statblock.AliasSpellbookSpell.mod",
    "desc": "The spell’s overridden spellcasting modifier. None if this spell uses the default caster spellcasting modifier.",
    "returns": {
      "type": "int or None"
    }
  },
  "AliasSpellbookSpell.prepared": {
    "url": "aliasing.api.statblock.AliasSpellbookSpell.prepared",
    "desc": "Whether or not the spell is prepared. If the spell is always prepared, the caster is not a prepared caster (e.g. Sorcerer), or the spell is a cantrip, this will be True.",
    "returns": {
      "type": "bool"
    }
  },
  "AliasSpellbookSpell.name": {
    "url": "aliasing.api.statblock.AliasSpellbookSpell.name",
    "desc": "The name of the spell.",
    "returns": {
      "type": "str"
    }
  },
  "AliasSpellbookSpell.sab": {
    "url": "aliasing.api.statblock.AliasSpellbookSpell.sab",
    "desc": "The spell’s overridden spell attack bonus. None if this spell uses the default caster spell attack bonus.",
    "returns": {
      "type": "int or None"
    }
  },
  "character().coinpurse": {
    "url": "aliasing.api.character.AliasCharacter.coinpurse",
    "desc": "The coinpurse of the character.",
    "returns": {
      "type": "AliasCoinpurse"
    }
  },
  "str(character().coinpurse)": {
    "url": "aliasing.api.character.AliasCoinpurse",
    "desc": "Returns a string representation of the entire coinpurse. If the csetting for Compact Coins is enabled, this will only return your float gold, otherwise will return all 5 coin types.",
    "returns": {
      "type": "str"
    }
  },
  "character().coinpurse[cointype]": {
    "url": "aliasing.api.character.AliasCoinpurse",
    "desc": "The value of the given coin type.",
    "returns": {
      "type": "int"
    }
  },
  "character().coinpurse.pp": {
    "url": "aliasing.api.character.AliasCoinpurse.pp",
    "desc": "The value of the given coin type.",
    "returns": {
      "type": "int"
    }
  },
  "character().coinpurse.gp": {
    "url": "aliasing.api.character.AliasCoinpurse.gp",
    "desc": "The value of the given coin type.",
    "returns": {
      "type": "int"
    }
  },
  "character().coinpurse.ep": {
    "url": "aliasing.api.character.AliasCoinpurse.ep",
    "desc": "The value of the given coin type.",
    "returns": {
      "type": "int"
    }
  },
  "character().coinpurse.sp": {
    "url": "aliasing.api.character.AliasCoinpurse.sp",
    "desc": "The value of the given coin type.",
    "returns": {
      "type": "int"
    }
  },
  "character().coinpurse.cp": {
    "url": "aliasing.api.character.AliasCoinpurse.cp",
    "desc": "The value of the given coin type.",
    "returns": {
      "type": "int"
    }
  },
  "character().coinpurse.total": {
    "url": "aliasing.api.character.AliasCoinpurse.total",
    "desc": "Returns the total amount of coins in your bag, converted to float gold.",
    "returns": {
      "type": "float"
    }
  },
  "character().coinpurse.autoconvert()": {
    "url": "aliasing.api.character.AliasCoinpurse.autoconvert",
    "desc": "Converts all of your coins into the lowest amount of coins possible. 100cp turns into 1gp, 5sp turns into 1ep, etc."
  },
  "character().coinpurse.coin_str(cointype: str)": {
    "url": "aliasing.api.character.AliasCoinpurse.coin_str",
    "desc": "Returns a string representation of the chosen coin type.",
    "returns": {
      "type": "str"
    },
    "param": [
      {
        "name": "cointype",
        "type": [
          "str"
        ],
        "desc": "The type of coin to return. `\\\"pp\\\"`, `\\\"gp\\\"`, `\\\"ep\\\"`, `\\\"sp\\\"`, and `\\\"cp\\\"`"
      }
    ]
  },
  "character().coinpurse.compact_str()": {
    "url": "aliasing.api.character.AliasCoinpurse.compact_str",
    "desc": "Returns a string representation of the compacted coin value.",
    "returns": {
      "type": "str"
    }
  },
  "character().coinpurse.get_coins()": {
    "url": "aliasing.api.character.AliasCoinpurse.get_coins",
    "desc": "Returns a dict of your current coinpurse.",
    "returns": {
      "type": "dict",
      "desc": "A dict of your current coinpurse, e.g. `{\\\"pp\\\":0, \\\"gp\\\":1, \\\"ep\\\":0, \\\"sp\\\":2, \\\"cp\\\":3, \\\"total\\\": 1.23}`"
    }
  },
  "character().coinpurse.modify_coins(pp: int = 0, gp: int = 0, ep: int = 0, sp: int = 0, cp: int = 0, autoconvert: bool = True)": {
    "url": "aliasing.api.character.AliasCoinpurse.modify_coins",
    "desc": "Modifies your coinpurse based on the provided values. If `autoconvert` is enabled, it will convert down higher value coins if necessary to handle the transaction. Returns a dict representation of the deltas.",
    "returns": {
      "type": "dict",
      "desc": "A dict representation of the delta changes for each coin type."
    },
    "param": [
      {
        "name": "pp",
        "type": [
          "int"
        ],
        "desc": "Platinum Pieces. Defaults to 0."
      },
      {
        "name": "gp",
        "type": [
          "int"
        ],
        "desc": "Gold Pieces. Defaults to 0."
      },
      {
        "name": "ep",
        "type": [
          "int"
        ],
        "desc": "Electrum Pieces. Defaults to 0."
      },
      {
        "name": "sp",
        "type": [
          "int"
        ],
        "desc": "Silver Pieces. Defaults to 0."
      },
      {
        "name": "cp",
        "type": [
          "int"
        ],
        "desc": "Copper Pieces. Defaults to 0."
      },
      {
        "name": "autoconvert",
        "type": [
          "bool"
        ],
        "desc": "Whether it should attempt to convert down higher value coins. Defaults to True"
      }
    ]
  },
  "character().coinpurse.set_coins(pp: int, gp: int, ep: int, sp: int, cp: int)": {
    "url": "aliasing.api.character.AliasCoinpurse.set_coins",
    "desc": "Sets your coinpurse to the provided values.",
    "param": [
      {
        "name": "pp",
        "type": [
          "int"
        ],
        "desc": "Platinum Pieces"
      },
      {
        "name": "gp",
        "type": [
          "int"
        ],
        "desc": "Gold Pieces"
      },
      {
        "name": "ep",
        "type": [
          "int"
        ],
        "desc": "Electrum Pieces"
      },
      {
        "name": "sp",
        "type": [
          "int"
        ],
        "desc": "Silver Pieces"
      },
      {
        "name": "cp",
        "type": [
          "int"
        ],
        "desc": "Copper Pieces"
      }
    ]
  }
}
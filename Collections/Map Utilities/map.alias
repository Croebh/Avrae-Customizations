embed
<drac2>
testVersion = False
argList = &ARGS&

# Comment the first line for `!map`, second line for `!move`

# args = argparse((['-t',combat().me.name if combat().me else combat().current.name] if combat() and (combat().me or combat().current) else []) + ['-move']+argList if argList else [])
args = argparse(argList)

# **********************
# *** Base Variables ***
# **********************

defaults = load_json(get_svar("mapDefaults") or "{}") or {}
mapsize  = defaults.get("size", "10x10") or "10x10"
maxSize  = 99
if mapsize != "JSON":
  mapSplitX, mapSplitY = mapsize.lower().split('x')
  mapX                 = max(min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize), 1)
  mapY                 = max(min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize), 1)
  mapsize              = f"{mapX}x{mapY}"
mapoptions      = defaults.get("options","")
mapbg           = defaults.get("background","")
mapinfo         = {}
mapview         = ""
mapviewsize     = ""
mapviewlocation = ""
mapattach       = ""
map             = "http://otfbm.io/"
walls           = []
objects         = []
loadedjson      = []
fow             = []
targ            = None
out             = {}
baseAlph        = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
alph            = []
for index in range(maxSize):
 letter = ""
 if index // 26:
  letter = baseAlph[(index // 26) - 1]
 letter += baseAlph[index % 26]
 alph.append(letter)
presetObjects   = load_json(get_gvar("9b15344a-1f09-43b5-b84e-f61e32e4a89a"))
overlays        = []
spelllist       = []
c               = combat()
gt              = c.get_combatant if c else None
debug           = []
desc            = []
finalMap        = ""
sizeOffset      = {"T":0, "S":0, "M":0, "L":1, "H":1, "G":2}
COL,SIZ         = {"w": "white", "bk": "black", "gy": "grey", "r": "red", "g": "green", "b": "blue", "y": "yellow", "p": "purple", "pk": "pink", "c": "cyan", "bn": "brown", "o": "orange"},{"T":"Tiny", "S":"Small", "M":"Medium", "L":"Large", "H":"Huge", "G":"Gargantuan"}

# Command Lists
helpCmds = ['?', 'help']
listCmds = ['spelllist', 'spellbook', 'maplist', 'bglist', 'backgroundlist', 'viewlist', 'battlelist', 'tokenlist']
tokenCmds = ['tokenimport']
overlayCmds = ['newspell', 'saveoverlay', 'savespell', 'deletespell', 'deleteoverlay', 'saveunderlay', 'deleteunderlay']
interactCmds = ['deletebattle']
noMapCmds = helpCmds+listCmds+tokenCmds+overlayCmds+interactCmds

# We don't have an aim point/target yet
aimPoint        = ""
aimTarget       = ""
targAimPoint    = ""
targAimTarget   = ""
aimStick        = False
targPoint       = ""
aim             = ""
effect          = None
effectName      = ""
effectTarget    = ""
prevLoc         = ""

# F-Strings like to yell at me for \'s
newline, targD, aimD, quote = "\n", "{targ}", "{aim}", '\\"'

# What characters do we need to strip from names?
nameStrip       = r"""'"()[]{}*?^%$&#/-_~“”‘’"""
</drac2>

<drac2>
# The default overlays, created by @Nerds and Dragons#2817
defaultSpells  = load_json(get_gvar("d456fdfa-a292-42a1-ab00-b884e79b702f"))
spellOverlays  = defaultSpells.copy()

# Grab the user selected spells, and update the main dict
# This allows the user to replace/update items in the original dict
userOverlays   = load_json(get('mapOverlays','{}'))
serverOverlays = load_json(get_svar('mapOverlays') or '{}')
spellOverlays.update(serverOverlays)
if typeof(userOverlays) == 'SafeDict':
 spellOverlays.update(userOverlays)
else:
 [spellOverlays.update(load_json(get_gvar(spells))) for spells in load_json(get('mapOverlays','{}')) if get_gvar(spells)]

# Iterate over the spell dict, making it a little easier to read. Only select the ones they are searching for, if they are searching
for spell, over in spellOverlays.items():
 if args.last('search', '').lower() in spell.lower():
  if typeof(over) == 'str':
   over = [over]
  overDesc = []
  if any("{targ}" in item for item in over) or argparse(over).last('effect'):
   overDesc.append("requires `-t`")
  if any("{aim}" in item for item in over):
   if overDesc:
    overDesc.append("`-aim`")
   else:
    overDesc.append("requires `-aim`")
  if argparse(over).last('effect'):
   overDesc.append(f"attaches to init effect `{argparse(over).last('effect')}`")
  spelllist.append(f"""**{spell}** - {', '.join(overDesc)}""".strip(',- '))
# Split the list into groups of 20, to ensure it stays a reasonable size
spellPagin = [spelllist[i:i+20] for i in range(0, len(spelllist), 20)]
</drac2>

<drac2>
#This allows the user to load a preset into -mapview
serverPresets=load_json(get_svar('mapPresets') or '{}')
userPresets=load_json(get('mapPresets', '{}'))
serverPresets.update(userPresets)
userPresets = serverPresets
if args.last('viewload') or args.last('loadview'):
 argsViewload = (args.last("viewload") or args.last('loadview')).lower()
 for searchViewload in userPresets:
  if argsViewload in searchViewload.lower():
   foundViewload = userPresets.get(searchViewload)
   args = argparse(["-mapview", foundViewload] + argList)
   desc.append(f"Loaded view `{searchViewload}`.")
   break
</drac2>

<drac2>
for overNum in [""]+[str(x) for x in range(1,11)]:
 if args.last('spell' + overNum):
  # Loop through our users spellOverlays, looking for that spell
  for spell in spellOverlays:
   if args.last('spell' + overNum).lower() in spell.lower():
    # If we find it, add the overlay to the args
    # If its a string, its just a `-over9`
    if typeof(spellOverlays.get(spell)) == "str":
     args = argparse(["-over" + overNum, spellOverlays.get(spell)] + argList)
    # If its a list, its starting with a -over9 and then theres other stuff
    elif typeof(spellOverlays.get(spell)) == "SafeList":
     adjustedList = [f"{x.strip('0123456789')}{overNum}" if x.startswith('-') else x for x in spellOverlays.get(spell)]
     if "under" in adjustedList:
      adjustedList.pop(adjustedList.index("under"))
      args = argparse(["-under" + overNum] + adjustedList + argList)
     else:
      args = argparse(["-over" + overNum] + adjustedList + argList)
    # We only care about the first result
    break
</drac2>

<drac2>
# Pulling up tokenlist to view all created tokens
serverTokens = load_json(get_svar('mapTokens') or '{}')
userTokens = load_json(get('mapTokens','{}'))
serverTokens.update(userTokens)
userTokens = serverTokens
tokenlist = [f"""**{tokens}** - `{str(over).replace('"',quote)}`""" for tokens, over in userTokens.items() if args.last('search','').lower() in tokens.lower()]
tokenPagin = [tokenlist[i:i+20] for i in range(0, len(tokenlist), 20)]
</drac2>

<drac2>
# Pulling up viewlist to view all created -mapview presets
# Only select the ones they are searching for, if they are searching
viewlist = [f"""**{presets}** - `{str(over).replace('"',quote)}`""" for presets, over in userPresets.items() if args.last('search','').lower() in presets.lower()]
# Split the list into groups of 20, to ensure it stays a reasonable size
presetPagin = [viewlist[i:i+20] for i in range(0, len(viewlist), 20)]
</drac2>

<drac2>
#Pulling up battlelist to view all created battles
serverBattles = load_json(get_svar('mapBattles') or '{}')
userBattles = load_json(get('mapBattles', "{}"))
serverBattles.update(userBattles)
userBattles = serverBattles
</drac2>

<drac2>
# Pulling up objectlist to view all objects
defaultObjects = load_json(get_gvar("b2c9c0d3-6492-4390-86b9-c02db4c8caa1"))
objectTypeSplit = [list(defaultObjects.items())[i:i+2] for i in range(0, len(defaultObjects), 2)]
objectTypeOut = []
for objectType1, objectType2 in objectTypeSplit:
  objectTypeOut.append(f"""{objectType1[0]:<2}-{objectType1[1]:<15} | {objectType2[0]:<2}-{objectType2[1]:<12}""")
objectlist = f""" -f 'Object Key|```{newline.join(objectTypeOut)}```' -image https://cdn.discordapp.com/attachments/746474041577308301/768303827338133584/Screen_Shot_2020-10-20_at_8.44.52_PM.png """
</drac2>

<drac2>
# If we're in combat, check all the things
if c:
 # Collect information on every combatant
 for combatant in c.combatants:

  # Grab map information, if it exists
  for attack in combatant.attacks:
   if attack.name == 'map':
    mapattach=combatant
    mapinfo=attack.raw.automation[0].text
</drac2>

<drac2>
if c:
 # If we found a `map` attack with information, parse it now
 if mapinfo:
  # Split and convert to dict. Couldn't use | here because of how -attack effects are parsed
  mapinfo=mapinfo.split(' ~ ')
  mapinfo={x[0].lower():x[1] for x in [item.split(': ') for item in mapinfo]}
  if mapinfo.get('size') == None:
    mapsize = defaults.get("size", "10x10") or "10x10"
  else:
    mapsize=mapinfo.get('size')
  #If user hasn't set mapsize = "JSON" then continue
  if mapsize != "JSON":
   if ":" in mapsize:
     mapLocSize = mapsize.split(':')
     mapviewlocation = f"{mapLocSize[0]}:"
     mapsize = mapviewsize = mapLocSize[1]
   if mapsize[0].isdigit():
    mapSplitX, mapSplitY = mapsize.lower().split('x')
    mapX = min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize)
    mapY = min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize)
   else:
    mapX = alph.index(''.join(x.upper() for x in mapsize if x.isalpha()))
    mapY = int(''.join(y for y in mapsize if y.isdigit()))
   mapsize = f"{mapX}x{mapY}"
  mapbg=mapinfo.get('background')
  mapoptions=mapinfo.get('options')
  walls = mapinfo.get('walls')
  walls = walls.split(', ') if walls else []
  objects = mapinfo.get('objects')
  objects = objects.split('/') if objects else []
  loadedjson = mapinfo.get('json')
  loadedjson = loadedjson.split(', ') if loadedjson else []
  fow = mapinfo.get('fow')
  fow = fow.split(', ') if fow else []
  if mapinfo.get('view'):
   mapviewlocation, mapviewsize = mapinfo.get('view').replace('::',':').split(':')
</drac2>

<drac2>
#This allows the user to save -mapview presets to their mapPresets uvar to be called using -loadview
if args.last('newview') or args.last('saveview') or args.last('deleteview'):
  #First option is to create the preset
  if args.last('newview') or args.last('saveview'):
   for addNewview in (args.get('newview') or args.get('saveview')):
    if "," in addNewview:
     userPresets.update({addNewview.split(",")[0]:addNewview.split(",")[1]})
    else:
     desc.append("You must separate the key and value with a comma when adding `-newview` entries.")
   set_uvar("mapPresets",dump_json(userPresets))
   desc.append(f"Created the mapview preset `{addNewview.split(',')[0]}`")
  #Here we can remove an already created preset
  if args.last('deleteview'):
   for searchDeleteView in args.get('deleteview'):
    userPresets.pop(searchDeleteView)
   set_uvar("mapPresets",dump_json(userPresets))
   desc.append(f"Removed Preset `{searchDeleteView}`")
</drac2>

<drac2>
# The default map bg's, created by @Nerds and Dragons#2817
presetMaps = load_json(get_gvar("a891401d-cdf2-44b2-b63b-bd86387c2659"))
mapBG = presetMaps.copy()
userMaps = load_json(get('mapBackgrounds','{}'))
serverMaps = load_json(get_svar('mapBackgrounds') or '{}')
# Grab the user selected map, and update the main dict
# This allows the user to replace/update items in the original dict
mapBG.update(serverMaps)
mapBG.update(userMaps)
# Iterate over the map dict, making it a little easier to read.
# Only select the ones they are searching for, if they are searching
maplist = []
for maps, info in mapBG.items():
 if args.last('search', '').lower() in maps.lower():
  infoDesc = []
  if typeof(info) == 'SafeList':
   info = {"mapbg": info[0], "mapsize": info[1] if len(info)>1 else None, "mapoptions": info[2] if len(info)>2 else None}
  elif typeof(info) == 'str':
   info = {"walls": info}
  if info.get('mapbg'):
   if len(info.get('mapbg')) > 100:
    infoDesc.append(f"Background (Long URL)")
   else:
    infoDesc.append(f"Background ([Link]({info.get('mapbg')}))")
  if info.get('mapsize'):
   infoDesc.append(f"{info.get('mapsize')}")
  if info.get('mapoptions'):
   infoDesc.append(f"Options (`{info.get('mapoptions')}`)")
  if info.get("walls"):
   if len(info.get("walls")) > 1:
    infoDesc.append(f"Walls ({len(info.get('walls'))})")
   else:
    infoDesc.append("Walls")
  if info.get("objects"):
   if len(info.get("objects")) > 1:
    infoDesc.append(f"Objects ({len(info.get('objects'))})")
   else:
    infoDesc.append("Objects")
  maplist.append(f"""**{maps}** - {', '.join(infoDesc)}""".strip(",- "))
# Split the list into groups of 1, to ensure it stays a reasonable size (used to be 20, then I added stuff)
mapPagin = [maplist[i:i+10] for i in range(0, len(maplist), 10)]
# Do we have a -loadmap?
if args.last('mapload') or args.last('loadmap'):
 # Loop through our users mapBackgrounds, looking for that map
 argLoadmap = (args.last('loadmap')or args.last('mapload')).lower()
 for maps in mapBG:
  if argLoadmap in maps.lower():
   foundMap = mapBG.get(maps)
   if 'mapbg' in foundMap:
    mapbg = foundMap.get('mapbg')
   else:
    mapbg = ""
   if 'mapsize' in foundMap:
    mapsize = foundMap.get('mapsize')
   if 'mapoptions' in foundMap:
    mapoptions = foundMap.get('mapoptions')
   else:
    mapoptions = ""
   if 'walls' in foundMap:
    walls = foundMap.get('walls')
   else:
    walls = []
   if 'objects' in foundMap:
    objects = foundMap.get('objects')
   else:
    objects = []
   if typeof(foundMap) == 'SafeList':
    mapbg = foundMap[0]
    mapsize = foundMap[1] if len(foundMap)>1 else ""
    mapoptions = foundMap[2] if len(foundMap)>2 else ""
    objects = []
    walls = []
   desc.append(f"Loaded the map: `{maps}`")
   if not args.last('silent'):
    if mapbg:
     desc.append(f"- Background: `{mapbg}`")
    if mapsize:
     desc.append(f"- Size: `{mapsize}`")
    if mapoptions:
     desc.append(f"- Options: `{mapoptions}`")
     if 'z' in mapoptions or mapoptions[0].isdigit():
      zoom = ""
      if 'z' in mapoptions:
       zoom = ",".join([char for char in mapoptions.split('z')[1][0:3] if char.isdigit() or char == "."]).replace(",", " ")
      else:
       zoom = ",".join([char for char in mapoptions[0:3] if char.isdigit() or char == "."]).replace(",", "")
      desc.append(f' -- Zoom set to {zoom}x')
     if 'd' in mapoptions:
      desc.append(f" -- Dark Mode")
     if 'n' in mapoptions:
      desc.append(f" -- Grid Hidden")
     if 'e' in mapoptions:
      desc.append(f" -- Disable Border Opacity")
     if 'f' in mapoptions:
      desc.append(f" -- Using alternative grid/token font")
     if 'c' in mapoptions:
      gsize = ""
      gsize = ",".join([char for char in mapoptions.split("c")[1][0:3] if char.isdigit()]).replace(",", "")
      desc.append(f' -- Grid size adjusted to {gsize} px')
     if 'h' in mapoptions:
      gtrans = ""
      gtrans = ",".join([char for char in mapoptions.split("h")[1][0:2] if char.isdigit()]).replace(",", "")
      desc.append(f' -- Grid transparancy adjusted to {gtrans}%')
     if 'o' in mapoptions:
       offset = ""
       for char in mapoptions[mapoptions.index('o')+1:]:
        if char.isdigit() or char == ":":
         offset += char
        else:
         break
       desc.append(f" -- Background Offset adjusted by {offset.replace(':', 'x')} px")
    if walls:
     desc.append(f"- Walls: `{', '.join(walls)}`")
    if objects:
     desc.append(f"- Objects: `{', '.join(objects)}`")
   neweffect = f"""{f"Size: {mapsize}" if mapsize else ""}{f" ~ Background: {mapbg}" if mapbg else ""}{f" ~ Options: {mapoptions}" if mapoptions else ""}{f' ~ Walls: {", ".join(walls)}' if walls else ""}{f' ~ Objects: {"/".join(objects)}' if objects else ""}{f" ~ View: {mapviewlocation}:{mapviewsize}" if mapviewsize and mapviewlocation else ""}""".strip(" ~")
   if mapattach:
    mapattach.add_effect('map', f"""-attack "||{neweffect}" """)
   break
</drac2>

<drac2>
#This allows the user to create custom mapbg presets and save them to their mapBackgrounds uvar to be loaded using -mapload
if args.last('newmapbg') or args.last('deletemapbg') or args.last('savemap') or args.last('deletemap'):
 #First option is to create mapbg preset
 if args.last('newmapbg') or args.last('savemap'):
  mapName = (args.last('savemap') or args.last('newmapbg')).lower()
  mapBGState = {}
  formedMap = {mapName:mapBGState}
  for key, value in mapinfo.items():
   if value:
    if mapinfo.get('background')!= None:
     mapBGState["mapbg"] = mapinfo.get('background')
    mapBGState["mapsize"] = mapsize
    if mapinfo.get('options')!= None:
     mapBGState["mapoptions"] = mapinfo.get('options')
    if mapinfo.get('walls')!= None:
     mapBGState["walls"] = mapinfo.get('walls').split(', ')
    if mapinfo.get('objects')!= None:
     mapBGState["objects"] = mapinfo.get('objects').split('/')
    if mapinfo.get('json')!= None:
     mapBGState["json"] = mapinfo.get('json').split('/')
  userMaps.update(formedMap)
  set_uvar("mapBackgrounds",dump_json(userMaps))
  desc.append(f"Created the map `{mapName}`")
 #Second option is to delete an already created map
 if args.last('deletemapbg') or args.last('deletemap'):
  argDeletemap = (args.last("deletemapbg") or args.last('deletemap')).lower()
  for searchMap in userMaps:
   if argDeletemap in searchMap.lower():
    userMaps.pop(searchMap)
    break
  set_uvar("mapBackgrounds",dump_json(userMaps))
  desc.append(f"Removed Map BG `{argDeletemap}`")
</drac2>
<drac2>
#Here we allow the user to save spell overlays in their mapOverlays uvar
if any(args.last(potentialArg) for potentialArg in (overlayCmds)):
 #First option is to create spell overlay
 if args.last('newspell') or args.last('savespell') or args.last('saveoverlay') or args.last('saveunderlay'):
  userOverlays = load_json(get('mapOverlays','{}'))
  for addNewspell in (args.get('saveoverlay') or args.get('newspell') or args.get('savespell') or args.get('saveunderlay')):
   newSpellSplit = addNewspell.split(":")
   if len(newSpellSplit) > 2:
    newSpellName = newSpellSplit[0]
    newSpellOverlay = newSpellSplit[1]
    newSpellEffect = newSpellSplit[2]
    if args.last('saveunderlay'):
     userOverlays.update({newSpellName:[newSpellOverlay, "under", "-effect", newSpellEffect]})
     desc.append(f"Created the underlay preset `{addNewspell.split(':')[0]}`")
    else:
     userOverlays.update({newSpellName:[newSpellOverlay, "-effect", newSpellEffect]})
     desc.append(f"Created the overlay preset `{addNewspell.split(':')[0]}`")
    set_uvar("mapOverlays",dump_json(userOverlays))
   elif len(newSpellSplit) == 2:
    newSpellName = newSpellSplit[0]
    newSpellOverlay = newSpellSplit[1]
    if args.last('saveunderlay'):
     userOverlays.update({newSpellName:[newSpellOverlay, "under"]})
    else:
     userOverlays.update({newSpellName:newSpellOverlay})
    set_uvar("mapOverlays",dump_json(userOverlays))
    desc.append(f"Created the overlay preset `{addNewspell.split(':')[0]}`")
   else:
     desc.append("You must separate the key and value with a colon when adding `-saveoverlay` or '-saveunderlay' entries.")
 #second option is to delete an already created spell/overlay
 if args.last('deletespell') or args.last('deleteoverlay') or args.last('deleteunderlay'):
  argDeletespell = (args.last("deletespell") or args.last('deleteoverlay') or args.last('deleteunderlay')).lower()
  for searchDeletespell in userOverlays:
   if argDeletespell in searchDeletespell.lower():
    foundDeletespell = userOverlays.pop(searchDeletespell)
    break
   else:
    desc.append("Did not find the spell you were looking for.")
  set_uvar("mapOverlays",dump_json(userOverlays))
  desc.append(f"Removed Saved Overlay/Underlay `{searchDeletespell}`")
</drac2>

<drac2>
if c:
 # Read each combatants notes for their information
 for target in c.combatants:
  # If they have a note, perse it into a dict
  if target.note and ':' in target.note:
   note=target.note
   note=note.split(" | ")
   note={x[0].lower():x[1] for x in [item.split(": ") for item in note]}
   if note.get('location'):
    note['location'] = note['location'].upper()
   out[target.name]=note
   # Check if we have any overlays attached to effects, and then if at effect exists
   for overNum in [""]+[str(x) for x in range(1,11)]:
    if out[target.name].get('effect'+overNum):
     checkEffect, checkEffectTarget = out[target.name].get('effect'+overNum).split(' / ')
     # If the effect (or the target it was on) are gone, remove the effect
     if not gt(checkEffectTarget) or not gt(checkEffectTarget).get_effect(checkEffect):
      _ = out[target.name].pop('effect'+overNum) if 'effect'+overNum in out[target.name] else None
      _ = out[target.name].pop('aim'+overNum) if 'aim'+overNum in out[target.name] else None
      _ = out[target.name].pop('overlay'+overNum) if 'overlay'+overNum in out[target.name] else None
      desc.append(f"""Overlay {overNum} removed from `{target.name}` because effect `{checkEffect}` no longer present{f" on {checkEffectTarget}" if checkEffectTarget!=target.name else ""}.""")
      desc.append("")
  elif target.note:
    note=target.note
    desc.append(f"Found a incorrectly formatted note on {target.name}, reformatted as a `-note`. ")
    out[target.name] = {"note": note.replace(':',' ').replace('|',' ')}
</drac2>

<drac2>
# Lets back up our map each time we run it, why not
# This will back the entire `out` dictionary containing everyones positions and states
# to a uvar named mapStates, with the current channels id added as s key inside it.
# This way you won't accidentally overwrite your backup with the backup from another channel

mapStates = load_json(get('mapStates','{}'))
prevBack = mapStates.get(chanid())
checkMS = str(mapStates)
lengthTotal = len(checkMS) + len(out)
if lengthTotal >= 10000:
  delete_uvar("mapStates")
  set_uvar('mapStates', dump_json(mapStates))
  desc.append(f"uvar mapStates was full, so it was cleared and current map setup was backed up")
else:
 mapStates.update({chanid(): out})
 set_uvar('mapStates', dump_json(mapStates))
# Clean up old uvars that are no longer needed
delete_uvar("mapState"+chanid())
delete_uvar("mapSize"+chanid())

# Then, if we have an undo in the arguments, we'll grab that backup (if it exists)
# and replace out out dict with it. We do this after we set the backup, so we can undo the undo
if args.last('undo') and prevBack:
  out = prevBack
  desc.append("> **Reloaded backup from last time this user ran a map command. The state this erased has now been set as their new backup.**")
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', c.me.name if c.me else None) and gt(args.last('t', c.me.name if c.me else None)):
  targ=gt(args.last('t', c.me.name if c.me else None))
  # If they don't have a note/location set, add them to the list
  if not out.get(targ.name):
   out[targ.name] = {}
  # If there is a -size arg, change their size
  if args.last('size'):
   size=args.last('size')[0].upper()
   # Confirm that the given size is valid before updating
   if size in SIZ:
    out[targ.name].update({"size":f"{size} ({SIZ[size]})"})
    # Display the change in size
    desc.append(f"Changing size of {targ.name} to {SIZ[size]} ({size})")
   # If the size is None, erase the size, setting them back to Medium
   elif args.last('size') in (None,"None","none"):
    if 'size' in out[targ.name]:
     _ = out[targ.name].pop('size')
    # Display the change in size
    desc.append(f"Resetting size of {targ.name} to Medium (M)")
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', c.me.name if c.me else None) and gt(args.last('t', c.me.name if c.me else None)):
  targ=gt(args.last('t', c.me.name if c.me else None))
  # If they don't have a note/location set, add them to the list
  if not out.get(targ.name):
   out[targ.name] = {}
  # If there is a -note arg, change their note
  if args.last("note"):
   newNote=args.last("note")
   if args.last("note") in (None, "None", "none", True):
    if 'note' in out[targ.name]:
     _ = out[targ.name].pop('note')
    # Display the change in the note
    desc.append(f"Removing the note on {targ.name}.")
   else:
    out[targ.name].update({"note":f"{newNote}"})
    # Display the change in size
    desc.append(f"Setting note of {targ.name} to {newNote}")
   # If the note is None, erase the note
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', c.me.name if c.me else None) and gt(args.last('t', c.me.name if c.me else None)):
  # If there is a -color arg, change their color
  if args.last('color'):
   color = args.last('color').lower().strip('~') + " "
   color = color[:color.index(' ')]
   # Confirm that the given color is valid before updating
   # Is it one of our preset colors?
   if color in COL:
    out[targ.name].update({"color":f"{color} ({COL[color]})"})
    # Display the change in color
    desc.append(f"Changing color of {targ.name} to {COL[color]} ({color})")
   # Or is it a hex code
   elif len(color) in (3, 6) and not color.strip("abcdef1234567890"):
    out[targ.name].update({"color":f"#{color.upper()}"})
    # Display the change in color
    desc.append(f"Changing color of {targ.name} to #{color.upper()}")
   # If the color is None, erase the color, setting them back to black
   elif args.last('color') in ("None","none"):
    _ = out[targ.name].pop('color')
    # Display the change in color
    desc.append(f"Resetting color of {targ.name} to Black")
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', c.me.name if c.me else None) and gt(args.last('t', c.me.name if c.me else None)):
  # If there is a -height arg, change their height
  if args.last('height'):
   height = args.last('height')
   # If the height is none or 0, remove height from the target
   if height in ("None","none","0"):
    if 'height' in out[targ.name]:
     prevHeight = out[targ.name].pop('height')
     if prevHeight:
      desc.append(f"{targ.name} is no longer {['above','below'][int(prevHeight.strip(' ft.m'))<0] if prevHeight.strip(' -+ft.m').isdigit() else 'above'} the ground.")
   else:
    # Otherwise, set that targets height
    out[targ.name].update({'height':height})
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', c.me.name if c.me else None) and gt(args.last('t', c.me.name if c.me else None)):
  # If there is a -group arg, change their group
  if args.last('group'):
   group = args.last('group')
   # If the group is none or 0, remove target from group
   if group in ("None","none","0"):
    if 'group' in out[targ.name]:
     prevGroup = out[targ.name].pop('group')
     if prevGroup:
      desc.append(f"You removed {targ} from {group}")
   else:
    # Otherwise, set that targets group
    out[targ.name].update({'group':group})
    desc.append(f"Set to be part of group {group}")
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', c.me.name if c.me else None) and gt(args.last('t', c.me.name if c.me else None)):
  # If there is a -token arg, change their token shortcode
  if args.last('token'):
   token = args.last('token')
   # If the token is none or 0, remove token from the target
   if token in ("None", "none", True, 'True', 'true'):
    prevToken = out[targ.name].pop('token')
    if prevToken:
     desc.append(f"{targ.name} is no longer using token {prevToken}.")
   else:
    # Otherwise, set that targets token
    out[targ.name].update({'token':token})
    desc.append(f"{targ.name} is now using the shortcode `{token}` as a token.")
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 # If no -t, default to current character
 if args.last('t', c.me.name if c.me else None) and gt(args.last('t', c.me.name if c.me else None)):
  prevLoc = out[targ.name].get('location')
  if args.last('move') and args.last('move') not in (True, 't', '-t', "TRUE") and (args.last('move')[0].isalpha() and args.last('move')[-1].isdigit()):
   # Fix bad locations?
   if prevLoc == "TRUE":
    _ = out[targ.name].pop('location')
    prevLoc = None
   # Did they have a previous location? If so, lets calculate distance and draw a line
   if prevLoc and prevLoc.lower() != args.last("move", "").lower():
    # Split previous location from XY to X and Y
    prevLocX = ''.join(x for x in prevLoc if x.isalpha())
    prevLocY = ''.join(y for y in prevLoc if y.isdigit())
    if prevLocY and prevLocX:
      prevLocY = int(prevLocY)
      # Same as new location
      newLocX = ''.join(x.upper() for x in args.last('move') if x.isalpha())
      newLocY = int(''.join(y for y in args.last('move') if y.isdigit()))
      # Calculate the delta for X and Y between the two
      deltaX, deltaY = alph.index(prevLocX)-alph.index(newLocX), int(prevLocY)-int(newLocY)
      # Throw them in the pot with some pythag
      distanceT = int(round(sqrt((deltaX*deltaX)+(deltaY*deltaY)),0))*5
      # We want the positive delta (wish we had abs(), sigh)
      deltaX, deltaY = deltaX if deltaX>=0 else deltaX*-1,deltaY if deltaY>=0 else deltaY*-1
      # Doing 5ft diag's, the distance is just the higher delta
      distance = max(deltaX, deltaY)*5
      # Grab the targets new color if changed, old color if set, or default to dark violet
      colr = (args.last('color', out[targ.name].get('color','w')) + " ").strip("#~").lower()
      colr = colr[:colr.index(" ")]
      if len(colr) in (3, 6) and not colr.strip("abcdef1234567890"):
        colr = f"~{colr}"
      # Add the line to the overlay list
      overlays.append(f"*a{distanceT}{colr}{prevLocX}{prevLocY}{newLocX}{newLocY}")
      # Display the change in location
      desc.insert(0, f"Moving {targ.name} from {prevLoc} to {args.last('move').upper()} ({f'~{distanceT}' if get_svar('trueDistance') or get('trueDistance') else distance} ft.).")
   else:
    # Display the change in location
    desc.insert(0, f"Moving {targ.name} to {args.last('move').upper()}.")
   out[targ.name].update({"location": args.last('move').upper()})
  elif args.last('move') and args.last('move') not in (True, 't', '-t', "TRUE") and (args.last('move')[0].isdigit() and args.last('move')[-1].isalpha()):
   desc.append(f"When trying to move a token, your coordinates needs to have letter first. Example: `A4`")
</drac2>

<drac2>
# Overlay stuff
if c:
  for overNum in [""]+[str(x) for x in range(1,11)]:
   for layType in ("over", "under"):
    # Is the user trying to set an overlay?
    if args.last(layType+overNum):
     # If we have a target, but our -over arg is none, we're trying to delete our overlay
     if args.last('t') and gt(args.last('t')) and (args.last(layType+overNum) in ("none", "None")):
      _ = out[targ.name].pop('overlay'+overNum) if 'overlay'+overNum in out[targ.name] else None
      _ = out[targ.name].pop('aim'+overNum) if 'aim'+overNum in out[targ.name] else None
      desc.append(f"Removed {layType}lay{' '+overNum if overNum else ''} linked to {targ.name}")
     else: # Split the input by commas
      overlay = args.last(layType+overNum).split(',')
      # First argument is always the shape, so lets pop it out
      oShape = overlay.pop(0).lower()

      # Are we attaching this to an effect?
      if args.last('effect'+overNum):
       # Split our effect up, in case we have a specified target
       effectName, effectTarget = (args.last('effect'+overNum).split('|')+[targ.name])[:2]
       effectTarget = gt(effectTarget)
       # Do we have a proper target, and does that target have our effect
       if effectTarget is not None and effectTarget.get_effect(effectName) is not None:
        effect = effectTarget.get_effect(effectName)

      # Are we aiming at someone?
      if args.last('aim'+overNum):
       # Split our aim up, in case we have a |split
       aim = (args.last('aim'+overNum).split('|')+[""])[:2]
       aimStick = (aim[1].lower() == "stick") or effect
       # Account for the user putting |stick on the wrong arg. Won't advertise this, as its unintended.
       if overlay[-1].endswith("|stick"):
         overlay[-1] = overlay[-1].replace("|stick", "")
         aimStick = True
       # If the target is, well, a target, grab its location
       for target in out:
        if aim[0].lower() in target.lower():
         aimPoint = out[target]['location']
         # Is our target larger than medium? If so, we need to offset to adjust
         if out[target].get('size',"M")[0] in "LHG":
          aimOffset = sizeOffset.get(out[target].get('size',"M")[0])
          aimTargX = ''.join(x for x in aimPoint if x.isalpha())
          aimTargY = int(''.join(y for y in aimPoint if y.isdigit()))
          aimTargX = alph[alph.index(aimTargX)+aimOffset]
          aimTargY += aimOffset
          aimPoint = f"{aimTargX}{aimTargY}"
         aimTarget = target
       # If the target wasn't a target, it was coordinates. Use them.
       if not aimPoint:
        aimPoint = aim[0]
        aimTarget = aim[0].upper()

      # Our basic structure, pre laid out
      currentOver = {"shape": "", "size": "", "width": ",", "color": "", "colorDesc": "", "loc": "", "eloc": ""}

      # This has all the information we need for our overlay[
      shapeDict = [{"type": "circle",       "name":"c",  "num": [3], "args": ("size", "color", "loc")},
                   {"type": "circletop",    "name":"ct", "num": [3], "args": ("size", "color", "loc")},
                   {"type": "circlecorner", "name":"co", "num": [3], "args": ("size", "color", "loc")},
                   {"type": "cone",         "name":"t",  "num": [4], "args": ("size", "color", "loc", "eloc")},
                   {"type": "line",         "name":"l",  "num": [5], "args": ("size", "width", "color", "loc", "eloc")},
                   {"type": "arrow",        "name":"a",  "num": [3], "args": ("color", "loc", "eloc")},
                   {"type": "square",       "name":"s",  "num": [3,4], "args": ("size", "color", "loc", "eloc")},
                   {"type": "squaretop",    "name":"st", "num": [3,4], "args": ("size", "color", "loc", "eloc")}]

      # Is the overlay valid?
      overValid = False

      # Did our user try to have the location linked to a target, but failed to supply a target?
      if "{targ}" in args.last(layType+overNum) and not (args.last('t') and gt(args.last('t'))):
       overlay = None
       desc.append(f"**Invalid {layType}lay arguments.** {newline}Be sure to have a `-t`/`-aim{overNum}` if using `{targD}` and `{aimD}`")
      # Same for aiming it at something. If they failed to supply a -aim#
      elif "{aim}" in args.last(layType+overNum) and not args.last('aim'+overNum):
       overlay = None
       desc.append(f"**Invalid {layType}lay arguments.** {newline}Be sure to have a `-t`/`-aim{overNum}` if using `{targD}` and `{aimD}`")
      else:
       # Otherwise, lets loop through our possible overlays
       for shape in shapeDict:
        # Does it have a valid amount of arguments for the given shape?
        if oShape == shape.type and len(overlay) in shape.num:
         currentOver['shape'] = shape.name
         # Iterate over the needed args
         for index in range(len(overlay)):
          # If its a color, we need to account for both preset colors and hex codes
          if shape.args[index] == "color":
           overlaycolor = overlay[index].lower().strip('~') + " "
           overlaycolor = overlaycolor[:overlaycolor.index(' ')].strip()
           # If this is in our preset colors, use that
           if overlaycolor in COL:
            currentOver[shape.args[index]] += overlaycolor
            currentOver['colorDesc'] += COL[overlaycolor]
           elif overlaycolor[:2] in COL:
            currentOver[shape.args[index]] += overlaycolor[:2]
            currentOver['colorDesc'] += COL[overlaycolor[:2]]
           elif overlaycolor[0]+overlaycolor[-1] in COL:
            currentOver[shape.args[index]] += overlaycolor[0]+overlaycolor[-1]
            currentOver['colorDesc'] += COL[overlaycolor[0]+overlaycolor[-1]]
           elif overlaycolor[:1] in COL:
            currentOver[shape.args[index]] += overlaycolor[:1]
            currentOver['colorDesc'] += COL[overlaycolor[:1]]
           # Otherwise, check if its a hex code, either 3 or 6 digits
           elif len(overlaycolor) in (3, 6) and not overlaycolor.strip("abcdef1234567890"):
            currentOver[shape.args[index]] += f"~{overlaycolor}"
            currentOver['colorDesc'] += f"#{overlaycolor.upper()}"
          else:
           currentOver[shape.args[index]] += overlay[index]
         # Set the overlay for the map
         overlay = f"""{"u" if layType == "under" else ""}{currentOver.shape}{currentOver.size}{currentOver.width.rstrip(',')}{currentOver.color}{currentOver.loc}{currentOver.eloc}"""
         # Set the description
         overdesc = f"""**{shape.type.replace("corner"," corner").replace("top"," top").title()} {layType.title()}lay {overNum}**
                        - Color: `{currentOver.colorDesc}`
                        {f"- Size: `{currentOver.size} ft. " + ("radius`" if shape.type in "circletop" else "long`" if shape.type in "coneline" else "wide`") if shape.type != "arrow" else ""}
                        {f"- {'Top-left' if shape.type in ('circletop','square','squaretop') else 'Starting' if shape.type == 'cone' else 'Centered'}: `{currentOver.loc.upper()}`" if shape.type not in ("arrow", "line") else f"- Start: `{currentOver.loc.upper()}`"}
                        {f"- Width: `{currentOver.width.strip(', ')} ft.`" if shape.type == "line" else ""}
                        {f"- Aim: `{aimTarget or currentOver.eloc.upper()}`" if shape.type not in "circletop" and (aimTarget or currentOver.eloc) else ""}
                        {f"- Effect: `{effect.name}` on `{effectTarget.name}`" if effect else ""}"""
         overdesc = '\n'.join([i.strip() for i in overdesc.split('\n') if i.strip()])
         # If we made it this far, the overlay is valid, so we can break out of the loop
         overValid = True
         break
      if not overValid:
       overlay = None
      # If, after all the parsing above, we managed to get a proper overlay, continue
      if overlay:
       # Do we have a -aim? If so, replace {aim} with the aimPoint gathered before, and display who you're aiming at
       if aimPoint:
        overdesc = overdesc.replace('{aim}',aimPoint)
       # Are we attaching this overlay to a target?
       if args.last('t') and gt(args.last('t')):
        if not aimPoint or (aimPoint and aimStick) or effect:
         # If so, and no -aim (or -aim but also stick), lets attach it to the notes
         out[targ.name].update({"overlay"+overNum: overlay})
         if aimStick:
          out[targ.name].update({"aim"+overNum: aimTarget})
         if effect:
          out[targ.name].update({f"effect{overNum}": f"{effect.name} / {effectTarget.name}"})
        else:
         # If so, and -aim, lets *not* attach it to the notes, and just display it once
         targPoint = out[targ.name].get('location','A1')
         # Is our target Large or bigger? If so, adjust accordingly
         if out[targ.name].get('size',"M")[0] in "LHG":
          targOffset = sizeOffset.get(out[targ.name].get('size',"M")[0])
          TargX = ''.join(x for x in targPoint if x.isalpha())
          TargY = int(''.join(y for y in targPoint if y.isdigit()))
          TargX = alph[alph.index(TargX)+targOffset]
          TargY += targOffset
          targPoint = f"{TargX}{TargY}"
         overlays.append(overlay.replace("{targ}", targPoint).replace("{aim}", aimPoint))
        desc.append(overdesc.replace('{targ}', out[targ.name].get('location','A1')) + newline + f"- Attached: `{targ.name}`")
       else:
        # Otherwise, lets just display it once
        overlays.append(overlay.replace("{aim}", aimPoint))
        desc.append(overdesc)
</drac2>

<drac2>
if c:
 for aimNum in [""]+[str(x) for x in range(1,11)]:
  # Is the user trying to change a -aim?
  # Make sure they don't have a `-over`
  if args.last('aim'+aimNum) and not (args.last('over'+aimNum) or args.last('under'+aimNum)):
   # Also make sure there is a valid target
   if (curTarg := args.last('t', c.me.name if c.me else None)) and (curTarg := gt(curTarg)):
    # And that target has an overlay, and an existing aim point
    if out[curTarg.name].get('overlay'+aimNum) and out[curTarg.name].get('aim'+aimNum):
     # If they used |stick, remove it, as its implied at this point
     aim = args.last('aim'+aimNum).split('|')[0]
     # If the aim target is, well, a target, grab its location
     for target in out:
      if aim.lower() in target.lower():
       aimPoint = out[target]['location']
       # Is our aim target larger than medium? If so, we need to offset to adjust
       if out[target].get('size',"M")[0] in "LHG":
        aimOffset = sizeOffset.get(out[target].get('size',"M")[0])
        aimTargX = ''.join(x for x in aimPoint if x.isalpha())
        aimTargY = int(''.join(y for y in aimPoint if y.isdigit()))
        aimTargX = alph[alph.index(aimTargX)+aimOffset]
        aimTargY += aimOffset
        aimPoint = f"{aimTargX}{aimTargY}"
       aimTarget = target
     # If its not a target, use coordinates
     if not aimPoint:
      aimPoint = aim
      aimTarget = aim.upper()
     # Notify the user as to what happened
     desc.append(f"""Aim point for Overlay {aimNum} on {curTarg.name} changed from {out[curTarg.name].get('aim'+aimNum)} to {aimTarget}.""")
     # Update the aim target
     out[curTarg.name].update({"aim"+aimNum: aimTarget})
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last("status"):
  if args.last('t') and gt(args.last('t')):
   targ = gt(args.last('t'))
   # If there is a -status arg, display all recorded map info on the target
   desc.append(f"**Status of {targ.name}**")
   if out.get(targ.name):
    for info in out[targ.name]:
     if info in ('aim', 'effect'):
      desc.append(f"- {info.title()}: `{out[targ.name][info]}`".replace(" / ", "` on target `"))
     else:
      desc.append(f"{info.title()}: `{out[targ.name][info]}`")
   else:
    desc.append("No information has been set yet.")
  else:
   if mapattach:
    desc.append(f"**Map settings (attached to {mapattach.name})**")
   for info in mapinfo:
    if info == "objects":
     objList = [f"{[objL[0] for objL in presetObjects.items() if obj[obj.index('$'):] in objL[1]][0]} at {obj[:obj.index('$')].upper()}" for obj in mapinfo[info].split("/")]
     desc.append(f"Objects: {' / '.join(objList) if len(objList) <= 10 else len(objList)}")
    else:
     desc.append(f"{info.title()}: `{mapinfo[info]}`")
    if info == "options":
     options = mapinfo[info]
     if 'z' in options or options[0].isdigit():
      zoom = ""
      if 'z' in options:
       zoom = ",".join([char for char in options.split('z')[1][0:3] if char.isdigit() or char == "."]).replace(",", "")
      else:
       zoom = ",".join([char for char in options[0:3] if char.isdigit() or char == "."]).replace(",", "")
      desc.append(f' -- Zoom set to {zoom}x')
     if 'd' in options:
      desc.append(f" -- Dark Mode")
     if 'n' in options:
      desc.append(f" -- Grid Hidden")
     if 'e' in options:
      desc.append(f" -- Disable Border Opacity")
     if 'f' in options:
      desc.append(f" -- Using alternative grid/token font")
     if 'c' in options:
      gsize = ""
      gsize = ",".join([char for char in options.split("c")[1][0:3] if char.isdigit()]).replace(",", "")
      desc.append(f' -- Grid size adjusted to {gsize} px')
     if 'h' in options:
      gtrans = ""
      gtrans = ",".join([char for char in options.split("h")[1][0:2] if char.isdigit()]).replace(",", "")
      desc.append(f' -- Grid transparancy adjusted to {gtrans}%')
     if 'o' in options:
      offset = ""
      for char in options[options.index('o')+1:]:
       if char.isdigit() or char == ":":
        offset += char
       else:
        break
      desc.append(f" -- Background Offset adjusted by {offset.replace(':', 'x')} px")
  if args.last('export'):
    if mapoptions != None or "":
      displayOptions = f"-options {mapoptions}"
    else:
      displayOptions = ""
    if fow != []:
      displayFOW = f" -fow {','.join(fow)}"
    else:
      displayFOW = ""
    if loadedjson != []:
      displayJSON = f" -json {','.join(loadedjson)}"
    else:
      displayJSON = ""
    if mapviewlocation != "":
      displayView = f" -view {mapviewlocation}:{mapviewsize}"
    else:
      displayView = ""
    if objects != []:
      rawObject = objects.split("$")
      objectDisplayLocation = rawObject[0]
      objectDisplayItem = rawObject[1]
      for item in presetObjects:
        if objectDisplayItem in item[1]:
          displayItem = presetObjects[0]
      displayObjects = f" -object {','.join()}"
    else:
      displayObjects = ""
    desc.append(f"\n**Exported Command:**\n`!map {displayOptions} -mapsize {mapsize} -bg {mapbg}{displayView}{displayFOW}{displayObjects}{displayJSON}`")
</drac2>

<drac2>
#Load user saved token list
if args.last('savetoken') or args.last('deletetoken'):
 if args.last('savetoken'):
  for addNewToken in args.get('savetoken'):
   if ":" in addNewToken:
    userTokens.update({addNewToken.split(":")[0]:addNewToken.split(":")[1]})
   else:
    desc.append("You must separate the key and value with a colon when adding `-savetoken` entries.")
  set_uvar("mapTokens",dump_json(userTokens).lower())
  desc.append(f"Created the Token `{addNewToken.split(':')[0]}`")
 if args.last('deletetoken'):
  argToken = args.last("deletetoken").lower()
  userTokens.pop(argToken)
  set_uvar("mapTokens",dump_json(userTokens).lower())
  desc.append(f"Removed Token `{argToken}`")
</drac2>

<drac2>
if c:
 for massTarg in args.get('t'):
  mTarg, mMove, mSize, mColor, mToken, mHeight = (massTarg.split('|') + ["","","","",""])[:6]
  if (mTarg := gt(mTarg)):
   # If they don't have a note/location set, add them to the list
   if not out.get(mTarg.name):
    out[mTarg.name] = {}
   if mMove:
    prevLoc = out[mTarg.name].get('location')
    # Did they have a previous location? If so, lets calculate distance and draw a line
    if prevLoc and prevLoc.lower() != mMove.lower():
     # Split previous location from XY to X and Y
     prevLocX = ''.join(x for x in prevLoc if x.isalpha())
     prevLocY = ''.join(y for y in prevLoc if y.isdigit())
     if prevLocY and prevLocX:
       prevLocY = int(prevLocY)
       # Same as new location
       newLocX = ''.join(x.upper() for x in mMove if x.isalpha())
       newLocY = int(''.join(y for y in mMove if y.isdigit()))
       # Calculate the delta for X and Y between the two
       deltaX, deltaY = alph.index(prevLocX)-alph.index(newLocX), int(prevLocY)-int(newLocY)
       # Throw them in the pot with some pythag
       distanceT = int(round(sqrt((deltaX*deltaX)+(deltaY*deltaY)),0))*5
       # We want the positive delta (wish we had abs(), sigh)
       deltaX, deltaY = deltaX if deltaX>=0 else deltaX*-1,deltaY if deltaY>=0 else deltaY*-1
       # Doing 5ft diag's, the distance is just the higher delta
       distance = max(deltaX, deltaY)*5
       # Grab the targets new color if changed, old color if set, or default to dark violet
       colr = (args.last('color', out[mTarg.name].get('color','w')) + " ").strip("#~").lower()
       colr = colr[:colr.index(" ")]
       if len(colr) in (3, 6) and not colr.strip("abcdef1234567890"):
         colr = f"~{colr}"
       # Add the line to the overlay list
       overlays.append(f"*a{distanceT}{colr}{prevLocX}{prevLocY}{newLocX}{newLocY}")
       # Display the change in location
       desc.insert(0, f"Moving {mTarg.name} from {prevLoc} to {mMove.upper()} ({f'~{distanceT}' if get_svar('trueDistance') or get('trueDistance') else distance} ft.).")
    else:
     # Display the change in location
     desc.insert(0, f"Moving {mTarg.name} to {mMove.upper()}.")
    out[mTarg.name].update({"location":mMove.upper()})
   if mSize:
    size=mSize[0].upper()
    # Confirm that the given size is valid before updating
    if size in SIZ:
     out[mTarg.name].update({"size":f"{size} ({SIZ[size]})"})
     # Display the change in size
     desc.append(f"Changing size of {mTarg.name} to {SIZ[size]} ({size})")
   if mColor:
    color = mColor.lower().strip('~') + " "
    color = color[:color.index(' ')]
    # Confirm that the given color is valid before updating
    # Is it one of our preset colors?
    if color in COL:
     out[mTarg.name].update({"color":f"{color} ({COL[color]})"})
     # Display the change in color
     desc.append(f"Changing color of {mTarg.name} to {COL[color]} ({color})")
    # Or is it a hex code
    elif len(color) in (3, 6) and not color.strip("abcdef1234567890"):
     out[mTarg.name].update({"color":f"#{color.upper()}"})
     # Display the change in color
     desc.append(f"Changing color of {mTarg.name} to #{color.upper()}")
   if mToken:
    if mToken.startswith("$"):
      tokenShort = mToken.replace("$", "")
      token = tokenShort
      out[mTarg.name].update({'token':token})
      desc.append(f"{mTarg.name} is now using the shortcode `{token}` as a token.")
    else:
      foundTokenload = None
      argsTokenload = mToken
      for searchTokenload in userTokens:
        if argsTokenload in searchTokenload.lower():
          token = userTokens.get(searchTokenload)
          desc.append(f"{mTarg.name} is now using the saved shortcode `{token}`.")
          out[mTarg.name].update({'token':token})
          break
   if mHeight:
    height = mHeight
    out[mTarg.name].update({'height':height})
    if mHeight in ("None","none","0"):
     if 'height' in out[mTarg.name]:
      prevHeight = out[mTarg.name].pop('height')
      if prevHeight:
       desc.append(f"{mTarg.name} is no longer {['above','below'][int(prevHeight.strip(' ft.m'))<0] if prevHeight.strip(' -+ft.m').isdigit() else 'above'} the ground.")
      else:
       # Otherwise, set that targets height
       out[mTarg.name].update({'height':height})
   if args.last('loadtoken'):
    foundTokenload = None
    argsTokenload = args.last('loadtoken').lower()
    for searchTokenload in userTokens:
     if argsTokenload in searchTokenload.lower():
      foundTokenload = userTokens.get(searchTokenload)
      desc.append(f"Loaded token `{searchTokenload}`.")
      out[mTarg.name].update({'token':foundTokenload})
      break
</drac2>

<drac2>
if args.last('tokenimport'):
 tokenimport = args.last('tokenimport').strip("<>")

 ascii=""" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"""
 asciitable={ch:code+32 for code,ch in enumerate(ascii)}
 asciitable['\r']=13
 asciitable['\n']=10
 a_ascii=[asciitable.get(c) for c in tokenimport]

 if any(ch is None for ch in a_ascii):
  err("Input needs to be ascii")

 b64_index = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

 ascii_bin_str = ""
 tokenoutput = ""

 for c in a_ascii:
     ascii_bin_str += f'{c:08b}'  # construct a binary-representation string

 numChunks = int(len(ascii_bin_str) / 6)  # how many 6
 for i in range(numChunks):
     chunk = ascii_bin_str[i * 6: (i + 1) * 6]
     tokenoutput += b64_index[int(chunk, base=2)]

 leftoverBits = len(ascii_bin_str) % 6  # since the input was a multiple of 8, this must be 2 or 4
 if leftoverBits > 0:
     leftover = ascii_bin_str[leftoverBits * -1:]
     if leftoverBits == 2:
         tokenoutput += b64_index[int(leftover+('0' * 4), base=2)]
         tokenoutput += ('=' * 2)
     elif leftoverBits == 4:
         tokenoutput += b64_index[int(leftover+('0' * 2), base=2)]
         tokenoutput += '='

 return f"""-title "Token Import" -desc "Token shortcode for `{args.last('tokenimport')}` can be found at [This Link](https://token.otfbm.io/meta/{tokenoutput}){newline}{newline}You can attach that shortcode to a target with `-token [shortcode]`" """
</drac2>

<drac2>
if c:
 # If theres a -mapsize, -bg, -options, -view, -attach, -view, -wall, -deletewall, -object, -deleteobject, -loadmap, -savebattle, -deletebattle, -loadbattle, -loadjson, -deletejson, -fow, or -addfow arg, process that and add/replace the effect
 if any(args.last(thisArg) for thisArg in ('mapsize', 'mapbg', 'bg', 'mapoptions', 'options', 'mapview', 'view', 'mapattach', 'attach', 'wall', 'deletewall', 'object', 'deleteobject', 'loadmap', 'mapload', 'savebattle', 'loadbattle', 'loadjson', 'deletejson', 'fow', 'addfow')) and not (args.last('help') or args.last('?')):
  # If the new mapsize is different from the old one, update and display
  if mapsize != args.last('mapsize', mapsize):
   #If user wants to set mapsize back to default
   if args.last('mapsize') in ('none', 'None', 'reset'):
    mapsize = defaults.get("size", "10x10") or "10x10"
   #If user wants to have the mapsize be pulled from a loaded json file
   elif args.last('mapsize') in ('json'):
    mapsize = "JSON"
   else:
    mapSplitX, mapSplitY = args.last('mapsize', mapsize).lower().split('x')
    mapSplitX = min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize)
    mapSplitY = min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize)
    mapsize = f"{mapSplitX}x{mapSplitY}"
   desc.append(f"Map size changed to `{mapsize}`")
  # If the new mapbg is different from the old one, update and display
  if mapbg != args.last('mapbg', args.last('bg', mapbg)):
   if args.last('mapbg', args.last('bg')) in ('none', 'None', 'reset'):
    mapbg = ""
    desc.append(f"Map background removed")
   else:
    mapbg = args.last('mapbg', args.last('bg', mapbg))
    desc.append(f"Map background changed to `{mapbg}`")
  if mapoptions != args.last('mapoptions', args.last('options', mapoptions)):
  # If the new mapoptions are different from the old ones, update and display
   if args.last('mapoptions', args.last('options')) in ('none', 'None', True, 'true', 'True', None):
    mapoptions = ""
    desc.append(f"Map options reset")
   else:
    types = [
          ('zoom', 'z', '.'),
          ('size', 'c', ''),
          ('trans', 'h', ''),
          ('offset', 'o', ':')
        ]

    options = {"old": {}, "new": {}}
    opt = args.last('mapoptions', args.last('options', ''))
    if mapoptions is None:
      mapoptions = ""

    for ver in options:
      base = opt if ver == "new" else mapoptions
      for full, short, add in types:
        if short in base:
          options[ver][full] = short
          for char in base[base.index(short)+1:]:
            if char.isdigit() or char == add:
              options[ver][full] += char
            else:
              break

    if opt:
      if opt.startswith(('+', '~', '-')):
        for type, value in options["new"].items():
          if type in options["old"]:
            opt = opt.replace(value, "")
            mapoptions = mapoptions.replace(options["old"][type],
              "" if opt.startswith('-') else value)
        if opt.startswith('-'):
          mapoptions = mapoptions.replace(opt.lstrip('-'), '')
        else:
          mapoptions += opt.lstrip('+~')
      else:
        mapoptions = opt

    desc.append(f"Map options changed to `{mapoptions}`")
    if 'z' in mapoptions or mapoptions[0].isdigit():
     zoom = ""
     if 'z' in mapoptions:
      zoom = ",".join([char for char in mapoptions.split('z')[1][0:3] if char.isdigit() or char == "."]).replace(",", "")
     else:
      mapoptions = "z" + mapoptions
      zoom = ",".join([char for char in mapoptions[0:3] if char.isdigit() or char == "."]).replace(",", "")
     desc.append(f' -- Zoom set to {zoom}x')
    if 'd' in mapoptions:
     desc.append(f" -- Dark Mode")
    if 'n' in mapoptions:
     desc.append(f" -- Grid Hidden")
    if 'e' in mapoptions:
     desc.append(f" -- Disable Border Opacity")
    if 'f' in mapoptions:
     desc.append(f" -- Using alternative grid/token font")
    if 'c' in mapoptions:
     gsize = ""
     gsize = ",".join([char for char in mapoptions.split("c")[1][0:3] if char.isdigit()]).replace(",", "")
     desc.append(f' -- Grid size adjusted to {gsize} px')
    if 'h' in mapoptions:
     gtrans = ""
     gtrans = ",".join([char for char in mapoptions.split("h")[1][0:2] if char.isdigit()]).replace(",", "")
     desc.append(f' -- Grid transparancy adjusted to {gtrans}%')
    if 'o' in mapoptions:
      offset = ""
      for char in mapoptions[mapoptions.index('o')+1:]:
       if char.isdigit() or char == ":":
        offset += char
       else:
        break
      desc.append(f" -- Background Offset adjusted by {offset.replace(':', 'x')} px")
  if mapview != args.last('mapview', args.last('view', mapview)):
   # Do they want to reset the map view?
   if args.last('mapview', args.last('view')).lower() in ('reset', 'none'):
    mapviewlocation = mapviewsize = ""
    desc.append(f"""Map view reset to default `{mapsize}`.""")
   else:
    # If the new mapview are different from the old one, update and display
    mapview = args.last('mapview', args.last('view', mapview))
    mapviewlocation = mapview.split(':')[0]
    mapviewsize = mapview.split(':')[1]
    if mapviewsize[0].isdigit():
     mapSplitX, mapSplitY = mapviewsize.lower().split('x')
     mapX = min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize)
     mapY = min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize)
    else:
     locX = alph.index(''.join(x.upper() for x in mapviewlocation if x.isalpha()))
     locY = int(''.join(y for y in mapviewlocation if y.isdigit()))
     mapX = alph.index(''.join(x.upper() for x in mapviewsize if x.isalpha()))
     mapY = int(''.join(y for y in mapviewsize if y.isdigit()))
     mapX = mapX - locX + 1
     mapY = mapY - locY + 1
    mapviewsize = f"{mapX}x{mapY}"
    desc.append(f"Map view changed to `{mapview if f'{mapviewlocation}:{mapsize}'==mapview else f'{mapview} ({mapviewsize})'}`")
  #If there is a -wall
  if args.last('wall'):
   #If user wants to clear all the walls at once
   if args.last('wall') in ('none', 'None', True, 'true', 'True'):
    walls = []
    desc.append(f"Walls reset.")
   else:
    inputtedWalls = args.last('wall')
    splitwall = inputtedWalls.split(",")
    if len(splitwall) >1:
     addedWalls = splitwall[0]
     wallColor = splitwall[1]
     finalWall = f"-c{wallColor}{addedWalls}"
     walls.append(finalWall)
     desc.append(f"Wall added: `{finalWall}`")
    else:
     walls.append(inputtedWalls)
     desc.append(f"Wall added: `{inputtedWalls}`")
  #If user wants to delete a specific wall
  if args.last('deletewall'):
   inputtedWalls = args.last('deletewall')
   remWalls = [wall for wall in walls if inputtedWalls.lower() != wall.lower()]
   if len(walls) != len(remWalls):
    desc.append(f"Wall removed: `{inputtedWalls}`")
    walls = remWalls
   else:
    desc.append(f"Could not find wall: `{inputtedWalls}`")
  #If there is a -object call
  if args.last('object') or args.last('deleteobject'):
   #If user wants to remove ALL objects
   if args.last('object'):
     if args.last('object') in ('none', 'None', True, 'true', 'True'):
      objects = []
      desc.append(f"Objects reset")
     else:
      foundObject = ""
      argsObject = args.last("object").lower().split(":")
      splitObject = argsObject[1].split(",")
      if len(splitObject) > 1:
        objectColor = splitObject[1]
      else:
        objectColor = ""
      for object in presetObjects:
       if splitObject[0] in object.lower():
        foundObject = presetObjects[object]
        break
      if foundObject:
       objectLocation = argsObject[0]
       loadedObject=objectLocation+objectColor+foundObject
       objects.append(loadedObject)
       desc.append(f"Object added `{object}:{loadedObject}`")
      else:
       desc.append("Could not find object")
   #If user wants to delete a specific object
   if args.last("deleteobject"):
     argsDeleteObject = args.last("deleteobject").lower().split(":")
     splitObject = argsDeleteObject[1].split(",")
     if len(splitObject) > 1:
       objectColor = splitObject[1]
     else:
       objectColor = ""
     for object in presetObjects:
       if splitObject[0] in object.lower():
         foundObject = presetObjects[object]
         break
     if foundObject:
       objectLocation = argsDeleteObject[0]
       loadedObject=objectLocation+objectColor+foundObject
     objects.remove(loadedObject)
     desc.append(f"Object `{object}:{loadedObject}` was removed")
  #If user wnats to do fog of war
  if args.last('fow'):
   #If user wants to remove ALL fog of war
   if args.last('fow') in ('none', 'None', 'reset', True, 'true', 'True'):
    fow = []
    desc.append(f"Fog of War Turned Off")
   else:
    argsFOW = args.last("fow").lower()
    if "," in argsFOW:
      multiFOW = argsFOW.split(",")
      fow.extend(multiFOW)
      displayMulti = str(multiFOW).replace("[", "").replace("]", "").replace("'", "")
      desc.append(f"Fog of War revealed at `{displayMulti}`")
    else:
      fow.append(argsFOW)
      desc.append(f"Fog of War revealed at `{argsFOW}`")
  #If user wants to add back a specific fog of war
  if args.last('addfow'):
   inputtedFOW = args.last('addfow').lower()
   remFOW = [fog for fog in fow if inputtedFOW.lower() != fog.lower()]
   if len(fow) != len(remFOW):
    desc.append(f"Fog of War added over `{inputtedFOW}`")
    fow = remFOW
   else:
    desc.append(f"Fog of War: `{inputtedFOW}` could not be added. You can only add back what you have specifically taken away.")
  if args.last('savebattle'):
   argsBattle = args.last('savebattle')
   mapBGState = {}
   for key, value in mapinfo.items():
    if value:
     if mapinfo.get('background')!= None:
      mapBGState["mapbg"] = mapinfo.get('background')
     mapBGState["mapsize"] = mapsize
     if mapinfo.get('options')!= None:
      mapBGState["mapoptions"] = mapinfo.get('options')
     if mapinfo.get('walls')!= None:
      mapBGState["walls"] = mapinfo.get('walls').split(', ')
     if mapinfo.get('objects')!= None:
      mapBGState["objects"] = mapinfo.get('objects').split('/')
     if mapinfo.get('view')!= None:
      mapBGState["view"] = mapinfo.get('view')
     if mapinfo.get('fow')!= None:
      mapBGState["fow"] = mapinfo.get('fow')
     if mapinfo.get('json')!= None:
      mapBGState["json"] = mapinfo.get('json')
     break
   savedBGState = {"mapattach":mapBGState}
   savedBGState.update(out)
   savedBattle = {argsBattle:savedBGState}
   userBattles.update(savedBattle)
   set_uvar("mapBattles",dump_json(userBattles))
   desc.append(f"Saved the battle `{argsBattle}`")
  if args.last('loadbattle'):
   argsBattle = args.last('loadbattle').lower()
   foundBattle = ""
   for searchBattle in userBattles:
    if argsBattle in searchBattle.lower():
     foundBattle = userBattles[searchBattle]
     foundBattleName = searchBattle
     for searchCombatant in foundBattle:
      if searchCombatant not in ("mapattach"):
       foundCombatants = dict(list(foundBattle.items())[1:])
       currentCombatants = [c.get_combatant(name)]
       #Here saved combatant notes are loaded unless combatant isn't in combat
       if all([c.get_combatant(searchCombatant) for searchCombatant in foundCombatants.keys()]):
        out = dict(list(foundBattle.items())[1:])
       else:
        #Here lets user know what combatants they need to add to load ther info
        missingCombatants = [combatants for combatants in foundCombatants if not c.get_combatant(combatants)]
        desc.append(f'You need to add the Combatant{"s" if len(missingCombatants) > 1 else ""} `{", ".join(missingCombatants)}` to load combatants info')
        break
       break
      foundMapload = foundBattle["mapattach"]
      if "mapbg" in foundMapload:
       mapbg = foundMapload["mapbg"]
      else:
       mapbg = mapbg
      if "mapsize"  in foundMapload:
       mapsize = foundMapload["mapsize"]
      if "mapoptions" in foundMapload:
       mapoptions = foundMapload["mapoptions"]
      else:
       mapoptions = mapoptions
      if "walls" in foundMapload:
       walls = foundMapload["walls"]
      else:
       walls = walls
      if "objects" in foundMapload:
       objects = foundMapload["objects"]
      else:
       objects = objects
      if "fow" in foundMapload:
       fow = foundMapload["fow"].split(", ")
      else:
       fow = fow
      if "json" in foundMapload:
       loadedjson = foundMapload["json"].split(", ")
      else:
       loadedjson = loadedjson
      if "view" in foundMapload:
       mapviewlocation, mapviewsize = foundMapload["view"].replace('::',':').split(':')
      desc.append(f"Loaded the battle `{foundBattleName}`")
  #If user wants to load a saved json file
  if loadedjson != args.last('loadjson', loadedjson):
    #If user wants to clear ALL loaded json files
    if args.last('loadjson') in ('none', 'None', 'reset'):
      loadedjson = []
      mapsize = defaults.get("size", "10x10") or "10x10"
      desc.append(f"JSON file removed")
    else:
      inputtedJson = args.last('loadjson')
      loadedjson.append(inputtedJson)
      desc.append(f"Loaded JSON File {inputtedJson}")
  #If user wants to delete a specific loaded json file
  if args.last('deletejson'):
   inputtedjson = args.last('deletejson')
   remjson = [json for json in loadedjson if inputtedjson.lower() != json.lower()]
   if len(loadedjson) != len(remjson):
    desc.append(f"JSON removed: `{inputtedjson}`")
    loadedjson = remjson
   else:
    desc.append(f"Could not find JSON: `{inputtedjson}`")
  # If there is a -mapattach, and its a valid target in init
  if args.last('mapattach', args.last('attach')) and gt(args.last('mapattach', args.last('attach'))):
   # First check if there is an existing mapattach, and if its the same as the new one, then remove their map effect
   if typeof(mapattach)=="SimpleCombatant" and gt(args.last('mapattach', args.last('attach'))).name != mapattach.name:
    mapattach.remove_effect('map')
   # Then, set the new mapattach
   mapattach = gt(args.last('mapattach', args.last('attach')))
  # If theres mapattach set, and they currently have a map effect, remove it
  if mapattach and mapattach.get_effect('map'):
   mapattach.remove_effect('map')
  # Format everything appropriately
  setMapView = f"{mapviewlocation}:{mapviewsize}"
  neweffect = f"""{f"Size: {mapsize}" if mapsize else ""}{f" ~ Background: {mapbg}" if mapbg else ""}{f" ~ Options: {mapoptions}" if mapoptions else ""}{f" ~ Walls: {', '.join(walls)}" if walls else""}{f' ~ Objects: {"/".join(objects)}' if objects else ""}{f" ~ View: {setMapView}" if setMapView.strip(':') else ''}{f' ~ FOW: {", ".join(fow)}' if fow else ""}{f' ~ JSON: {", ".join(loadedjson)}' if loadedjson else ""}""".strip(" ~")
  # If mapattach exists, apply the new effect, and display
  if mapattach:
   mapattach.add_effect('map', f"""-attack "||{neweffect}" """)
   desc.append(f"Map settings attached to `{mapattach.name}`")
  # Otherwise, show that it was changed, but not saved
  else:
    # Look for a combatant named DM or Map, auto attach
    for maptarg in ("map", "dm", "lair"):
     if c.get_combatant(maptarg):
      mapattach = c.get_combatant(maptarg)
      mapattach.add_effect('map', f"""-attack "||{neweffect}" """)
      desc.append(f"""Autoattached map settings to {mapattach.name}""")
      break
    else:
     desc.append("Map settings changed, but no map attach target was found. Settings not saved.")
# Handle commands that don't require interacting with combat or the map
if any(args.last(thisArg) for thisArg in interactCmds):
 if args.last('deletebattle'):
  #add battlelist for diplaying
  args.update({"battlelist": "True"})
  inputtedBattle = args.last('deletebattle')
  foundBattle = None
  for battle in userBattles:
   if inputtedBattle.lower() in battle.lower():
    foundBattle = userBattles.pop(battle)
    set_uvar("mapBattles", dump_json(userBattles))
    desc.append(f"Deleted the battle `{battle}`")
    break
  if not foundBattle:
   desc.append(f"Did not find the battle you were looking for")
</drac2>

<drac2>
if c:
 # Parse the collected notes and information into the format readable by otfbm.com
 people = []
 for target in out:
  tLocation = out[target].get('location')
  tSize = out[target].get('size','M')[0].upper()
  tColor = out[target].get('color', 'b' if '/' in gt(target).hp_str() else 'r') + " "
  tColor = tColor[:tColor.index(" ")].strip('#')
  tToken = out[target].get('token')
  # Account for hex colors
  if len(tColor) in (3, 6):
   tColor = f"~{tColor}".upper()
  tName = target.translate(str.maketrans(' ', '_', nameStrip))
  # Only display if they have a location
  if tLocation:
    people.append(f"{tLocation}{tSize}{tColor}-{tName}{f'~{tToken}' if tToken else ''}")
  # Do they have a height set? If so, display it
  if out[target].get('height'):
   desc.append(f"{target} is currently {out[target].get('height').strip('-+')} ft. {['above','below'][int(out[target].get('height').strip(' ft.m'))<0] if out[target].get('height').strip(' -+ft.m').isdigit() else 'above'} the ground.")
  # Do they have overlays?
  for overNum in [""]+[str(x) for x in range(1,11)]:
    # Ensure we're not grabbing the previous overlays aim point
    targAimPoint = ""
    if out[target].get('overlay'+overNum):
     targPoint = out[target].get('location','A1')
     # Is our target Large or bigger? If so, adjust accordingly
     if out[target].get('size',"M")[0] in "LHG":
      targOffset = sizeOffset.get(out[target].get('size',"M")[0])
      TargX = ''.join(x for x in targPoint if x.isalpha())
      TargY = int(''.join(y for y in targPoint if y.isdigit()))
      TargX = alph[alph.index(TargX)+targOffset]
      TargY += targOffset
      targPoint = f"{TargX}{TargY}"
     # If the target has an aim point set
     if out[target].get('aim'+overNum):
      for aimTarget in out:
       # We need to check to see if they were targetting a... target
       if out[target].get('aim'+overNum).lower() in aimTarget.lower():
        targAimPoint = out[aimTarget]['location']
        # Is our aimTarget larger than medium? If so, we need to offset to adjust
        if out[aimTarget].get('size',"M")[0] in "LHG":
         targAimOffset = sizeOffset.get(out[aimTarget].get('size',"M")[0])
         targAimTargX = ''.join(x for x in targAimPoint if x.isalpha())
         targAimTargY = int(''.join(y for y in targAimPoint if y.isdigit()))
         targAimTargX = alph[alph.index(targAimTargX)+targAimOffset]
         targAimTargY += targAimOffset
         targAimPoint = f"{targAimTargX}{targAimTargY}"
       # If the aimTarget wasn't a target, it was coordinates. Use them.
       if not targAimPoint:
        targAimPoint = out[target].get('aim'+overNum).upper()
     # Add each targets overlay to the overlays list
     overlays.append(out[target].get('overlay'+overNum).replace("{targ}", targPoint).replace("{aim}", targAimPoint).strip("*"))
 # Reconvert all of our map information back into the readable note format
 dataout={x:' | '.join([f"{item[0].title()}: {item[1]}"for item in out[x].items()])for x in out}
 # Then set everyones note again. Kinda a chainsaw instead of a scalpel situation here.
 for target in dataout:
  gt(target).set_note(dataout[target])
 # If a 'clear' arg is given, clear the entire map (clears everyones notes)
 if args.last('clear'):
  [i.set_note(None)for i in combat().combatants]
  people=[]
  overlays=[]
 # Join everything together and display the map if we aren't displaying the help

 # Analytics removed, temporarily:
 # &cid={ctx.channel.id}&sid={ctx.guild.id}&uid={ctx.author.id}{"&d=1" if testVersion else ""}

 overlays = [f"*{overlay.strip('*')}" for overlay in overlays]
 if not any(args.get(arg) for arg in (noMapCmds)):
  finalMap = f"""{map}{mapsize}{f"/{mapviewlocation}:{mapviewsize}" if mapviewsize and mapviewlocation else ""}/{f'_{"_".join(walls)}/' if walls else ""}{f"@{mapoptions}/"if mapoptions else""}{f'{"/".join(objects)}/' if objects else ""}{f'{"*f"+"/*f".join(fow).replace(":", "")}/' if fow else ""}{'/'.join(people+overlays)}{f"?load={'&load='.join(loadedjson)}" if loadedjson else ""}?a=1{f"&bg={mapbg}" if mapbg else ""}"""
  return f"""{'' if args.last('silent') else f'-image "{finalMap}"'} -f "[Map]({finalMap})" """ + (f"""  -desc "{newline.join(desc)}"  """ if desc else "")
</drac2>

<drac2>

colorSplit = [list(COL.items())[i:i+2] for i in range(0, len(COL), 2)]
colorOut = []
for color1, color2 in colorSplit:
  colorOut.append(f"""{color1[0]:<3}- {color1[1]:<6} | {color2[0]:<3}- {color2[1]:<6}""")

helpindex = f"""
-f "Help Index|`!map help` - Basic Commands and Tokens
`!map help <manage|dm>` - Visual Options and Map Views
`!map help <over|spells>` - Overlays and Spells
`!map help <walls|doors|objects>` - Walls, Doors and Objects
**Additional help**
Check our [Documentation website](http://docs.otfbm.com/) to find every command and argument explained in detail and with practical examples.
**Support Us**
You can support OTFBM on [Patreon](https://www.patreon.com/otfbm) and this alias at [Ko-Fi](https://ko-fi.com/croebh)"
"""
colorhelp = f"""-f "Valid Colors|```{newline.join(colorOut)}```You can also provide 3 or 6 digit hex codes, like `D73` or `D2773f`|inline" """
sizehelp = f"""-f "Valid Sizes|```{newline.join([f"{x[0]} - {x[1]}" for x in SIZ.items()])}```|inline" """

# Build the Battle list here, as it could have changed before
battlelist = []
for battle, info in userBattles.items():
 if args.last('search', '').lower() in battle.lower():
  indivBattles = dict(list(info.items())[1:])
  indivCombatant = []
  for combatant in indivBattles:
   if combatant != "mapattach":
    overs = len([i for i in indivBattles[combatant] if i.startswith('overlay')])
    indivCombatant.append(f"""`{combatant}`{f" ({overs} Overlay{'s' if overs>1 else ''})" if overs else ""}""")
  battlelist.append(f"""**{battle}** - Combatants: {', '.join(indivCombatant)}""".strip(",- "))
# Split the list into groups of 15, to ensure it stays a reasonable size (used to be 20, then I added stuff)
battlePagin = [battlelist[i:i+15] for i in range(0, len(battlelist), 15)]

# Go through and Add some pizazz for any lists, paginate the ones that are too large - Exclude objectlist from pagination 
# Are we trying to display the spelllist?
if args.get('spelllist') or args.get('spellbook'):
 # Only grab the page selected, default to first
 if spellPagin:
  spellPage = f"""-desc "{newline.join(spellPagin[ min(len(spellPagin),args.last('page', 1, int)-1)] )}" """
 else:
  spellPage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return spellPage + f"""-title "Wait, how do you Spell that again?"
                        -f "Add your own overlays/spells| You can add your own overlays/spells by running the command `-saveoverlay <overlay/spellname>:<overlay>`"
                        -f "`{targD}` and `{aimD}`| These will be replaced by the `-t` target and `-aim` target respectively."  """
# Are we trying to display the maplist?
elif args.get('maplist') or args.get('bglist') or args.get('backgroundlist'):
 # Only grab the page selected, default to first
 if mapPagin:
  mapPage = f"""-desc "{newline.join(mapPagin[ min(len(mapPagin),args.last('page', 1, int)-1)] )}" """
 else:
  mapPage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return mapPage + f"""-title "Where are we at on the map?"
                        -f "Add your own maps| You can add your own maps by running the command `-savemap <mapname>`"  """
elif args.get('viewlist'):
 # Only grab the page selected, default to first
 if presetPagin:
  presetPage = f"""-desc "{newline.join(presetPagin[ min(len(presetPagin),args.last('page', 1, int)-1)] )}" """
 else:
  presetPage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return presetPage + f"""-title "Say hello to my little preset"
                        -f "Add your own `-mapview` presets| You can create your own presets by running the command `-saveview <presetname>,<mapview preset>`"  """
elif args.get('tokenlist'):
     # Only grab the page selected, default to first
 if tokenPagin:
  tokenPage = f"""-desc "{newline.join(tokenPagin[ min(len(tokenPagin),args.last('page', 1, int)-1)] )}" """
 else:
  tokenPage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return tokenPage + f"""-title "Token for your thoughts"  """
elif any(args.get(arg) for arg in ['battlelist']):
 # Only grab the page selected, default to first
 if battlePagin:
   # Add the existing description to handle deletebattle
  battlePage = f"""-desc "{newline.join(desc)+newline+newline if desc else ''}{newline.join(battlePagin[ min(len(battlePagin),args.last('page', 1, int)-1)] )}" """
 else:
  battlePage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return battlePage + f"""-title "Knowing is half the battle"  """
elif args.get('objectlist'):
 # Add some pizazz
 return objectlist + f"""-title "I've got a loveley bunch of Objects, diddly dee" """
# If we're not in combat, or "?" or "help" are given as arguments, display the help
elif (not c or args.get('?') or args.get('help')) and not args.get("tokenimport"):
 if any(args.last(potentialArg) for potentialArg in ('overlay', 'over', 'overlays', 'spell', 'spells')):
  help = f"""-title "Maps: overlays and spells"
            -desc "{["Bro","Broski","Brotein","Brosicle","Broseph","Brotastic","Han Brolo","Broba Fett","Brotato Chip","Broseidon","Brochacho","Broebh"][randint(12)]}, I'm so Over this!
            Check our [Overlays Guide](http://docs.otfbm.com/#/guides-overlays) for detailed explanations of the commands below. Note: radius, size, length and width are in feet. For valid colours see below.
            For all of the below arguments, `-over` can be replaced with `-under` to adjust 'where' the overlay goes. `-over` places overlays on top of tokens, while `-under` places overlays under tokens."
            -f "_ _|**__Basic Overlays__**
            `-over circle,<radius>,<color>,<center>` - Draws a circle centered on a coordinate.
            `-over circletop,<radius>,<color>,<topleft>` - Draws a circle from the top left coordinate.
            `-over circlecorner,<radius>,<color>,<topleftcorner>` - Draws a circle centered on the top left corner of a coordinate.
            `-over cone,<size>,<color>,<start>,<end>` - Draws a cone with start and aim coordinates.
            `-over line,<length>,<width>,<color>,<start>,<end>` - Draws a line with start and end coordinates.
            `-over arrow,<color>,<start>,<end>` - Draws an arrow with start and end coordinates.
            `-over square,<size>,<color>,<topleft>[,end]` - Draws a square from a top left coordinate. Optional: Aim at a coordinate to rotate the square.
            `-over squaretop,<size>,<color>,<topleft>,<end>` - Draws a square from a top left coordinate, but when aimed the pivot point is the top left corner."
            -f "_ _|**__Other commands__**
            `-over [args] -t <target>` - Your overlay keeps disappearing? Without a `-t`, an overlay defaults to showing only once. This means the next time you run `!map` it won't be there. Target a combatant to stick an overlay to it and it'll remain visible until removed.
            `-over none -t <target>` - Removes an overlay attached to a target.
            `-saveoverlay <name>:<overlay>[:effect name]` - Saves a overlay, in the `spellbook`(see bellow), for quick access. Example: `!map -saveoverlay Explosion:circle,30,r,J5`. You can also save an effect, which allows you to 'connect' an overlay to an init effect on a target. All overlay names and effects that are more than one word, need to be within quotes. Example: `!map -saveoverlay \\"Fire Circle\\":circle,20,r,{aimD}:\\"Fire Circle\\"`
            `-deleteoverlay <name>` - Deletes a saved overlay."
            -f "_ _|**__Overlays as Spells__**
            `!map spellbook` - Lists all ready-made spell overlays.
            `-spell <spellname>` - Draws the spell, from the overlays' spellbook, on the map.
            Check out `!se ?` to quickly place preset spell effect overlays or ones you have saved."
            -f "_ _|**__Aiming and Connecting Overlays__**
            `-aim [target]` - Allows you to aim an overlay at a target. Use `{aimD}` in the `-over` command in order grab it. Works on both locations (`A3`) and targets (`OR3`). If a `-t` is provided as well, it won't attach the overlay to them. Can be used to move an existing aimed overlay.
            `-aim [target]|stick` - Same as above, but it *will* attach the overlay to a `-t` if provided, and will attach the `-aim` info as well.
            `-effect \"<effect>[|effectTarget]\"` - Allows you to 'connect' an overlay to an init effect on a target. When the effect or target are no longer present, the overlay will be removed. See `!help init effect` for details on creating them.
            You can replace coordinates with `{targD}` to have those coordinates linked with the `-t` target. For example, `!map -over circle,30,b,{targD} -t OR1` would cause it to be positioned on top of OR1, regardless of where they move.
            If your `-aim` or `-t` is a Large or bigger monster, the alias will try to adjust for the size difference."
            -f "_ _|**__Multiple Overlays__**
            You can create multiple overlays at a time by appending a number, from 1 to 9, to the end of the `-over`/`-under`/`-aim`/`-effect`/`-spell` argument. For example: `!map -over1 [args] -over2 [args]`
            Note: `-over2`/`-spell2` will be linked to `-aim2` and `-effect2`, and so on, for each overlay."
            """.replace(" "*11,"") + colorhelp
 elif any(args.last(potentialArg) for potentialArg in ('map', 'manage', 'options', 'dm', 'gm')):
  help =  """-title "Maps: Visual Options"
             -desc "Wait, were we in the dungeon or the pub?
             **__Allow the Map Settings to Save__**
             The map attaches these settings automatically to any combatant in the initiative order that's named `DM`, `Map`, or `Lair`. Attaching a map allows every change that's made to it to be saved. We recommend adding a dedicated combatant for this, instead of a player or a monster, to prevent the map from vanishing when a player exits combat, or a monster is killed. Regardless, you can manually attach the map to any other combatant by running `-attach <target>`.
             If these settings are run when they aren't attached to a `-attach` target, then the change will be temporary, and will be switched back to your default the next time you run the `!map` command.
             You can view the current map settings by running `!map status`"
             -f "__Map Size and Background Image__|
             `-mapsize <size>` - Sets the size of the map. Example: `!map -mapsize 20x20`
             `-bg <url>` - Imports an image to use as background. Use `-options c` / `o`, see below, to scale / offset the image to match the grid."
             `-bg none` - Removes the background.
             -f "__Ready-Made Maps__|
             `!map maplist` - Lists all ready-made maps.
             `-savemap <name>` - Saves a map with your current background, options, walls, objects for quick access. Uses your `mapBackgrounds` uvar.
             `-loadmap <name>` - Loads a saved map.
             `-deletemap <name>` - Deletes a saved map."
             -f "__Map views__|
             You can focus on a portion of a map as well as shift that view, expand it, or reduce it. You also have the option to save a view, so later on you can load it quickly.
             To do so use `!view`. Type `!view ?` to see help"
             -f "__Saving, Loading and Deleting Battles__|
             `!map battlelist` - Lists all saved battles.
             `-savebattle <name>` - Saves a battle, for quick access. This will include your map settings, as well as combatants and any overlays that are attached to them.
             `-loadbattle <name>` - Loads a saved battle.
             `-deletebattle <name>` - Deletes a saved battle."
             -f "__Fog of War__|
             `-fow <coordinate>[:<coordinate>]` - Turns fog of war on but reveals a single coordinate or what's between a set of coordinates. Example: `!map -fow j5` or `!map -fow b1:e5`
             You can add multiple fog of war coordinates in one command, just seperate them by a `,`. Example: `!map -fow a1:d4,h7:k11`
             `-fow none` - Turns fog of war off and makes everything visible.
             `-addfow <coordinate>[:<coordinate>]` - Conceals a single coordinate or what's between a set of coordinates that has already been revealed. Run `!map status` to see what specific coordinates can be selected. Example: If fog of war has been revelaed at B1:E5 - `!map -addfow b1:e5`"
             -f "__Loading and Deleting Json Files__|
             `-loadjson <url>` - Loads Json file. You can continue to run this command as many times you want, the files will append one after the other.
             `-deletejson <url>` - Deletes A Specific Json File
             `-loadjson reset` - Deletes All Json Files
             See [Predefined Maps and Tokens](http://docs.otfbm.com/#/predefined-maps-and-tokens) for detailed explanation.
             You do need to set `-mapsize json` if you want the JSON file to overwrite the default `-mapsize` settings."
             -f "__Interface Options__|
             `-options [args]` - Changes visual options using the following arguments:
             `z<#>` - Changes the map's resolution, range 1-3, accepts fractions. The higher the value the larger the map will be, allowing to zoom in without loosing image quality. Example: `!map -options z1.5`
             `d` - Dark mode
             `h<#>` - Sets the grid's transparency, range 1-99. Example: `!map -options h10` would set it to 10%.
             `n` - Hides the grid.
             `e` - Everything outside the map's edges becomes invisible.
             `f` - Use alternative grid/token font
             `c<#>` - Sets the grid's unit size (in px). Default: 60.
             `o<#>:<#>` - Offsets the background image (in px). Example: `!map -options o20:40` would offset it 20px down and 40px to the right.
             "
             -f "_ _|Run `-options` without a specific argument to revert its change. With no arguments it'll reset every change.
             You can set multiple settings at a time. Example: `!map -options dc70o10:20z2e`
             If you prepend with `+` or `~`, it will add or replace your settings. Example: If your settings are `c40n`, `!map -options +c45d` will set it to `c45nd`.
             If you prepend with `-`, you can remove settings. Example: If your settings are `c45nd`, `!map -options -nd` will set it to `c45`"
             -f "__Backup / Restore__|
             `!map undo` - Reverts all combatants to the state of last time you ran a `!map` command. You only have one undo, and running `!map undo` a second time undoes it. This information is kept in the `mapStates` uvar, keyed to the channel ID."
             -f "__Server Settings__|
             To set defaults for your server, simply create an svar named `mapDefaults`, containing a dict as follows, filling in the information as needed:
             `!svar mapDefaults {\\\"size\\\":\\\"\\\", \\\"background\\\":\\\"\\\", \\\"options\\\":\\\"\\\"}`
             You can also copy your `mapOverlays`, `mapPresets`, `mapTokens`, `mapBattles`, `trueDistance` uvars into svars, and they'll be set/available for the whole server."
  """
 elif any(args.last(potentialArg) for potentialArg in ('walls', 'wall', 'door', 'doors', 'object', 'objects')):
  help = f"""-title "Map: Walls, Doors and Objects"
             -desc "**__Allow the Walls and Objects to Save__**
             The map attaches these walls and objects automatically to any combatant in the initiative order that's named `DM`, `Map`, or `Lair`. Attaching a map allows every change that's made to it to be saved. We recommend adding a dedicated combatant for this, instead of a player or a monster, to prevent the map from vanishing when a player exits combat, or a monster is killed. Regardless, you can manually attach the map to any other combatant by running `-attach <target>`.
             If these walls and objects are run when they aren't attached to a `-attach` target, then the change will be temporary, and will be removed the next time you run the `!map` command.

             **__Walls and Doors__**
             Check our [Walls and Doors Guide](http://docs.otfbm.com/#/wallsanddoors) for detailed explanations of the commands below."

             -f "_ _|**__Walls__**
             `-wall <coordinate><coordinate>[,color]` - Draws a wall directly onto the grid, between two coordinates. Example: `!map -wall B3J3` would draw a line from B3 to J3. You can add multiple walls in one command, just separate them by a `_`. Example: `!map -wall M9P9_P9S6`
             When adding walls you can change the color of it. Example: `!map -wall B2B9,r`.
             `-wall none` - Clears all walls added
             `-deletewall <code>` - Allows you to delete an individual wall"

             -f "_ _|**__Doors__**
             You can add doors to walls with following arguments:
             `-o` - Open Door.
             `-d` - Closed Door.
             `-b` - Double Door.
             `-s` - Secret Door.
             Put one of these arguments between two coordinates that make a wall to draw a door in the middle. Example: `!map -wall B3-oD3` would draw an open door between B3 and D3."

             -f "_ _|**__Objects__**
             `-object <location>:<object>` - Adds an object to the map. Some objects can be placed over multiple squares, to do so add a second coordinate after the first. Example: `!map -object A1B4:trap` would expand an trap object from A1 to B4.
             `-deleteobject <location>:<object>` - Deletes the specified object from the map

             See `!map objectlist` for a list of objects"
             """
 else:
  help = f"""-title "Dude, where did I park my Tarrasque?"
             -desc "**__First time using this alias?__**
             Check our [Getting Started Guide](http://docs.otfbm.com/#/guides_getting_started) to learn how to set up your first map."
             -f "_ _|**__Basic commands__**
             `!map` - Shows the map.
             `!map [args]` - Edits the map, its combatants, or its overlays. The several arguments are all explained in these help screens.
             `!map status [export]` - Shows the map's details. If `export` is provided at the end, it shows as well an export line that you can copy and paste to load that particular map quickly.
             `!map clear`- Clears all notes, tokens, and overlays from every combatant.
             `!map undo` - Reverts all combatants to the state of last time you ran a `!map` command. You only have one undo, and running `!map undo` a second time undoes it. This information is kept in the `mapStates` uvar, keyed to the channel ID.
             `silent` - This will hide the map for a smaller embed when changing settings."
             -f "_ _|**Tokens**
             **__Targeting Combatants__**
             `-t <target>` - Targets a combatant and, paired with the following arguments, changes its token. Without `-t` the argument will apply to the active combatant.
             `-t <target>|[location]|[size]|[color]|[tokenname] or [$shortcode]|[height]` - Allows mass moving/editing targets. You can have many of these in one command, and if you don't want to set a particular arg, leave it blank. `-t WO1||Large` would set it to large, without changing its color, location, token or height. For token shortcode section, you can either enter the token name or `$shortcode`. Example: `!map -t go1|d4|||goblin -t prixaris|h8|m|b|$cgz94` See below on how to savetokens."
             -f "_ _|**__Placing or Moving Tokens__**
             `-move <coordinate>` - Places a token or moves it to the specified coordinate.
             `!move <coordinate>` - As an alternative to `-move`, this alias moves the active combatant with a shorter command."
             -f "_ _|**__Customizing tokens__**
             `-color <color>` - Sets the token's colour. `-color none` will reset it. Valid colours below.
             `-tokenimport <url>` - Takes an image url and prints its shortcode.
             `-token <shortcode>` - Places an image on a targeted token.
             `-size <size>` - Sets the token's size. `-size none` will reset it. Valid sizes below.
             `-height <+/-#>` - Sets the target's position relative to the ground, which will be displayed above the map. `-height none` will reset it."
             -f "_ _|**__Other commands__**
             `-note <note>` - Sets an arbitrary note on the target.
             `-t <target> status` - Shows the target's details.
             `-savetoken <tokenName>:<shortcode>` - Saves a token to your `mapTokens` uvar. `!map tokenlist` to see your saved tokens.
             `-deletetoken <tokenName>` - Deletes a token you have saved
             `-loadtoken <tokenName>` - Allows you to load a saved token to a target. Example: `!map -t go1 -loadtoken goblin`"
             -f "_ _|**__Additional Information__**
             The map calculates distances based on 5ft diagonals. If you would rather 'True' distances, run `!uvar trueDistance true`. To revert back, use `!uvar delete trueDistance`. You can also set this at a server level with `!svar trueDistance true`" """ + colorhelp + sizehelp

 help += helpindex
 if not combat():
  help += f""" -f "Important Note|This alias uses the initiative tracker, and as such, won't work outside of init." """

 return '\n'.join([i.lstrip() for i in help.split('\n')])
</drac2>

<drac2>
paginFooter = ""
pageList = [spellPagin, spellPagin, mapPagin, mapPagin, mapPagin, presetPagin, battlePagin, tokenPagin ]
# listCmds ['spelllist', 'spellbook', 'maplist', 'bglist', 'backgroundlist', 'viewlist', 'battlelist', 'tokenlist']
# Iterate over the lists we paginate
if any(args.last(arg) for arg in (listCmds)):
  paginFooter = f" | Page {args.last('page', 1)} / #### | -page # to change page"
  for i,cmd in enumerate(listCmds):
    if args.last(cmd):
      paginFooter = paginFooter.replace("####", str(len(pageList[i]))) if pageList[i] and len(pageList[i]) > 1 else ""
  paginFooter += " | -search [name] to search"

</drac2>
-footer "!map ?{{f" | Map settings attached to {mapattach.name}" if mapattach else ""}}{{paginFooter}} | v3.5"
<drac2>
# this is for debugging
if testVersion:
  return f"""-f "Debug|```
  {targ=}
  {overlays=}
  {people=}
  {debug=}
  {objects=}
  {walls=}```" """
</drac2>
-color <color>

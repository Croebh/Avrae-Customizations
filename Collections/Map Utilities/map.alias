embed 
<drac2>
testVersion = False
args = "@@@" if typeof("@@@") == "SafeList" else &ARGS&
defaults = "&&&" if typeof("&&&") == "SafeDict" else None

# Comment the first line for `!map`, second line for `!move`
# args = argparse((['-t',combat().me.name if combat().me else combat().current.name] if combat() and (combat().me or combat().current) else []) + ['-move']+args if args else [])
args = argparse(args)

# Set are base variables
defaults = load_json(get_svar("mapDefaults") or "{}") or defaults or {}
mapsize = defaults.get("size", "10x10") or "10x10"
maxSize = 99
mapSplitX, mapSplitY = mapsize.lower().split('x')
mapX = max(min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize), 1)
mapY = max(min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize), 1)
mapsize = f"{mapX}x{mapY}"
mapoptions = defaults.get("options","")
mapbg = defaults.get("background","")
mapinfo = {}
mapview = ""
mapviewsize = ""
mapviewlocation = ""
mapattach = ""
map="http://otfbm.io/"
walls = []
objects = []
out={}
baseAlph = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
alph = []
for index in range(maxSize):
  letter = ""
  if index // 26:
    letter = baseAlph[(index // 26) - 1]
  letter += baseAlph[index % 26]
  alph.append(letter)
col,siz=("w","bk","gy","r","g","b","y","p","c","bn","o","pk"), "TSMLHG"
COL,SIZ = {"w": "white", "bk": "black", "gy": "grey", "r": "red", "g": "green", "b": "blue", "y": "yellow", "p": "purple", "pk": "pink", "c": "cyan", "bn": "brown", "o": "orange"},{"T":"Tiny", "S":"Small", "M":"Medium", "L":"Large", "H":"Huge", "G":"Gargantuan"}
presetObjects = {"Trap": "$T", "Pillar Round": "$P", "Pillar Square": "$p", "Statue": "$S", "Open Pit": "$O", "Covered Pit": "$o"}
overlays=[]
c = combat()
gt = c.get_combatant if c else None
debug = []
desc = []
finalMap = ""
sizeOffset = {"T":0, "S":0, "M":0, "L":1, "H":1, "G":2}
# We don't have an aim point/target yet
aimPoint = ""
aimTarget = ""
targAimPoint = ""
targAimTarget = ""
aimStick = False
targPoint = ""
aim = ""
effect = None
effectName = ""
effectTarget =""
prevLoc = ""
# F-Strings like to yell at me for \'s
newline, targD, aimD, quote = "\n", "{targ}", "{aim}", '\\"'
# What characters do we need to strip from names?
nameStrip = r"""'"()[]{}*?^%$&#/-~“”‘’"""
</drac2>
<drac2>
# The default overlays, created by @Nerds and Dragons#2817 
defaultSpells = load_json(get_gvar("d456fdfa-a292-42a1-ab00-b884e79b702f"))
spellOverlays = defaultSpells.copy()
# Grab the user selected spells, and update the main dict
# This allows the user to replace/update items in the original dict
userOverlays    = load_json(get('mapOverlays','{}'))
serverOverlays = load_json(get_svar('mapOverlays') or '{}')
spellOverlays.update(serverOverlays)
if typeof(userOverlays) == 'SafeDict':
 spellOverlays.update(userOverlays)
else:
 [spellOverlays.update(load_json(get_gvar(spells))) for spells in load_json(get('mapOverlays','{}')) if get_gvar(spells)]
 # Iterate over the spell dict, making it a little easier to read.
# Only select the ones they are searching for, if they are searching
spelllist = []
for spell, over in spellOverlays.items():
 if args.last('search', '').lower() in spell.lower():
  if typeof(over) == 'str':
   over = [over]
  overDesc = []
  if any("{targ}" in item for item in over) or argparse(over).last('effect'):
   overDesc.append("requires `-t`")
  if any("{aim}" in item for item in over):
   if overDesc:
    overDesc.append("`-aim`")
   else:
    overDesc.append("requires `-aim`")
  if argparse(over).last('effect'):
   overDesc.append(f"attaches to init effect `{argparse(over).last('effect')}`")
  spelllist.append(f"""**{spell}** - {', '.join(overDesc)}""".strip(',- '))
# Split the list into groups of 20, to ensure it stays a reasonable size
spellPagin = [spelllist[i:i+20] for i in range(0, len(spelllist), 20)]
# Do we have a -spell#?
</drac2>
<drac2> # L318
serverPresets=load_json(get_svar('mapPresets') or '{}')
userPresets=load_json(get('mapPresets', '{}'))
serverPresets.update(userPresets)
userPresets = serverPresets
#This allows the user to load a preset into -mapview
if args.last('viewload') or args.last('loadview'):
 argsViewload = (args.last("viewload") or args.last('loadview')).lower()
 for searchViewload in userPresets:
  if argsViewload in searchViewload.lower():
   foundViewload = userPresets.get(searchViewload)
   args = argparse(["-mapview", foundViewload] + "@@@")
   desc.append(f"Loaded view `{searchViewload}`.")
   break
</drac2>
<drac2>
for overNum in [""]+[str(x) for x in range(1,11)]:
 if args.last('spell' + overNum):
  # Loop through our users spellOverlays, looking for that spell
  for spell in spellOverlays:
   if args.last('spell' + overNum).lower() in spell.lower():
    # If we find it, add the overlay to the args
    # If its a string, its just a `-over9`
    if typeof(spellOverlays.get(spell)) == "str":
     args = argparse(["-over" + overNum, spellOverlays.get(spell)] + "@@@")
    # If its a list, its starting with a -over9 and then theres other stuff
    elif typeof(spellOverlays.get(spell)) == "SafeList":
     adjustedList = [f"{x.strip('0123456789')}{overNum}" if x.startswith('-') else x for x in spellOverlays.get(spell)]
     args = argparse(["-over" + overNum] + adjustedList + "@@@")
    # We only care about the first result
    break
</drac2>

<drac2>
# Pulling up tokenlist to view all created tokens
serverTokens = load_json(get_svar('mapTokens') or '{}')
userTokens = load_json(get('mapTokens','{}'))
serverTokens.update(userTokens)
userTokens = serverTokens
tokenlist = [f"""**{tokens}** - `{str(over).replace('"',quote)}`""" for tokens, over in userTokens.items() if args.last('search','').lower() in tokens.lower()]
tokenPagin = [tokenlist[i:i+20] for i in range(0, len(tokenlist), 20)]
</drac2>

<drac2>
# Pulling up viewlist to view all created -mapview presets 
# Only select the ones they are searching for, if they are searching
viewlist = [f"""**{presets}** - `{str(over).replace('"',quote)}`""" for presets, over in userPresets.items() if args.last('search','').lower() in presets.lower()]
# Split the list into groups of 20, to ensure it stays a reasonable size
presetPagin = [viewlist[i:i+20] for i in range(0, len(viewlist), 20)]
</drac2>

<drac2>
#Pulling up battlelist to view all created battles
serverBattles = load_json(get_svar('mapBattles') or '{}')
userBattles = load_json(get('mapBattles', "{}"))
serverBattles.update(userBattles)
userBattles = serverBattles
battlelist = []
for battle, info in userBattles.items():
 if args.last('search', '').lower() in battle.lower():
  indivBattles = dict(list(info.items())[1:])
  indivCombatant = []
  for combatant in indivBattles:
   if combatant != "mapattach":
    overs = len([i for i in indivBattles[combatant] if i.startswith('overlay')])
    indivCombatant.append(f"""`{combatant}`{f" ({overs} Overlay{'s' if overs>1 else ''})" if overs else ""}""")
  battlelist.append(f"""**{battle}** - Combatants: {', '.join(indivCombatant)}""".strip(",- "))
# Split the list into groups of 15, to ensure it stays a reasonable size (used to be 20, then I added stuff)
battlePagin = [battlelist[i:i+15] for i in range(0, len(battlelist), 15)]
</drac2>

<drac2>
# If we're in combat, check all the things
if c:
 # Collect information on every combatant
 for combatant in combat().combatants:

  # Grab map information, if it exists
  for attack in combatant.attacks:
   if attack.name == 'map':
    mapattach=combatant
    mapinfo=attack.raw.automation[0].text
</drac2>

<drac2>
if c:
 # If we found a `map` attack with information, parse it now
 if mapinfo:
  # Split and convert to dict. Couldn't use | here because of how -attack effects are parsed
  mapinfo=mapinfo.split(' ~ ')
  mapinfo={x[0].lower():x[1] for x in [item.split(': ') for item in mapinfo]}
  mapsize=mapinfo.get('size')
  if ":" in mapsize:
    mapLocSize = mapsize.split( ':')
    mapviewlocation = f"{mapLocSize[0]}:"
    mapsize = mapviewsize = mapLocSize[1]
  if mapsize[0].isdigit():
   mapSplitX, mapSplitY = mapsize.lower().split('x')
   mapX = min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize) 
   mapY = min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize)
  else:
   mapX = alph.index(''.join(x.upper() for x in mapsize if x.isalpha()))
   mapY = int(''.join(y for y in mapsize if y.isdigit()))
  mapsize = f"{mapX}x{mapY}" 
  mapbg=mapinfo.get('background')
  mapoptions=mapinfo.get('options')
  walls = mapinfo.get('walls')
  walls = walls.split(', ') if walls else []
  objects = mapinfo.get('objects')
  objects = objects.split('/') if objects else []
  if mapinfo.get('view'):
   mapviewlocation, mapviewsize = mapinfo.get('view').replace('::',':').split(':')
</drac2>

<drac2>
#This allows the user to save -mapview presets to their mapPresets uvar to be called using -loadview
if args.last('newview') or args.last('saveview') or args.last('deleteview'):
  #First option is to create the preset
  if args.last('newview') or args.last('saveview'):
   for addNewview in (args.get('newview') or args.get('saveview')):
    if "," in addNewview:
     userPresets.update({addNewview.split(",")[0]:addNewview.split(",")[1]})
    else:
     desc.append("You must separate the key and value with a comma when adding `-newview` entries.")
   set_uvar("mapPresets",dump_json(userPresets))
   desc.append(f"Created the mapview preset `{addNewview.split(',')[0]}`")
  #Here we can remove an already created preset
  if args.last('deleteview'):
   for searchDeleteView in args.get('deleteview'):
    userPresets.pop(searchDeleteView)
   set_uvar("mapPresets",dump_json(userPresets))
   desc.append(f"Removed Preset `{searchDeleteView}`")
</drac2>

<drac2>
# The default map bg's, created by @Nerds and Dragons#2817 
presetMaps = load_json(get_gvar("a891401d-cdf2-44b2-b63b-bd86387c2659"))
mapBG = presetMaps.copy()
userMaps = load_json(get('mapBackgrounds','{}'))
serverMaps = load_json(get_svar('mapBackgrounds') or '{}')
# Grab the user selected map, and update the main dict
# This allows the user to replace/update items in the original dict
mapBG.update(serverMaps)
mapBG.update(userMaps)
# Iterate over the map dict, making it a little easier to read.
# Only select the ones they are searching for, if they are searching
maplist = []
for maps, info in mapBG.items():
 if args.last('search', '').lower() in maps.lower():
  infoDesc = []
  if typeof(info) == 'SafeList':
   info = {"mapbg": info[0], "mapsize": info[1] if len(info)>1 else None, "mapoptions": info[2] if len(info)>2 else None}
  elif typeof(info) == 'str':
   info = {"walls": info}
  if info.get('mapbg'):
   if len(info.get('mapbg')) > 200:
    infoDesc.append(f"Background (Long URL)")
   else:
    infoDesc.append(f"Background ([Link]({info.get('mapbg')}))")
  if info.get('mapsize'):
   infoDesc.append(f"{info.get('mapsize')}")
  if info.get('mapoptions'):
   infoDesc.append(f"Options (`{info.get('mapoptions')}`)")
  if info.get("walls"):
   if len(info.get("walls")) > 1:
    infoDesc.append(f"Walls ({len(info.get('walls'))})")
   else:
    infoDesc.append("Walls")
  if info.get("objects"):
   if len(info.get("objects")) > 1:
    infoDesc.append(f"Objects ({len(info.get('objects'))})")
   else:
    infoDesc.append("Objects")
  maplist.append(f"""**{maps}** - {', '.join(infoDesc)}""".strip(",- "))
# Split the list into groups of 15, to ensure it stays a reasonable size (used to be 20, then I added stuff)
mapPagin = [maplist[i:i+15] for i in range(0, len(maplist), 15)]
# Do we have a -loadmap?
if args.last('mapload') or args.last('loadmap'):
 # Loop through our users mapBackgrounds, looking for that map
 argLoadmap = (args.last('loadmap')or args.last('mapload')).lower()
 for maps in mapBG:
  if argLoadmap in maps.lower():
   foundMap = mapBG.get(maps)
   if 'mapbg' in foundMap:
    mapbg = foundMap.get('mapbg')
   else:
    mapbg = ""
   if 'mapsize' in foundMap:
    mapsize = foundMap.get('mapsize')
   if 'mapoptions' in foundMap:
    mapoptions = foundMap.get('mapoptions')
   else:
    mapoptions = ""
   if 'walls' in foundMap:
    walls = foundMap.get('walls')
   else:
    walls = []
   if 'objects' in foundMap:
    objects = foundMap.get('objects')
   else:
    objects = []
   if typeof(foundMap) == 'SafeList':
    mapbg = foundMap[0]
    mapsize = foundMap[1] if len(foundMap)>1 else ""
    mapoptions = foundMap[2] if len(foundMap)>2 else ""
    objects = []
    walls = []
   desc.append(f"Loaded the map: `{maps}`")
   if not args.last('silent'):
    if mapbg:
     desc.append(f"- Background: `{mapbg}`")
    if mapsize:
     desc.append(f"- Size: `{mapsize}`")
    if mapoptions:
     desc.append(f"- Options: `{mapoptions}`")
     if mapoptions[0].isdigit():
      zoom = ""
      for char in mapoptions:
       if char.isdigit() or char == ".":
        zoom += char
       else:
        break
      desc.append(f" -- Zoom set to {zoom}x")
     if 'd' in mapoptions:
      desc.append(f" -- Dark Mode")
     if 'n' in mapoptions:
      desc.append(f" -- Grid Hidden")
     if 'e' in mapoptions:
      desc.append(f" -- Disable Border Opacity")
     if 'f' in mapoptions:
      desc.append(f" -- Using alternative grid/token font")
     if 'c' in mapoptions:
      gsize = ""
      for char in mapoptions[mapoptions.index('c')+1:]:
       if char.isdigit():
        gsize += char
       else:
        break
      desc.append(f" -- Grid size adjusted to {gsize} px")
     if 'h' in mapoptions:
      gtrans = ""
      for char in mapoptions[mapoptions.index('h')+1:]:
       if char.isdigit():
        gtrans += char
       else:
        break
      desc.append(f" -- Grid transparancy adjusted to {gtrans}%")
     if 'o' in mapoptions:
      offset = ""
      for char in mapoptions[mapoptions.index('o')+1:]:
       if char.isdigit() or char == ":":
        offset += char
       else:
        break
      desc.append(f" -- Background Offset adjusted by {offset.replace(':', 'x')} px")
    if walls:
     desc.append(f"- Walls: `{', '.join(walls)}`")
    if objects:
     desc.append(f"- Objects: `{', '.join(objects)}`")
   neweffect = f"""{f"Size: {mapsize}" if mapsize else ""}{f" ~ Background: {mapbg}" if mapbg else ""}{f" ~ Options: {mapoptions}" if mapoptions else ""}{f' ~ Walls: {", ".join(walls)}' if walls else ""}{f' ~ Objects: {"/".join(objects)}' if objects else ""}{f" ~ View: {mapviewlocation}:{mapviewsize}" if mapviewsize and mapviewlocation else ""}""".strip(" ~")
   if mapattach:
    mapattach.add_effect('map', f"""-attack "||{neweffect}" """) 
   break
</drac2>

<drac2>
#This allows the user to create custom mapbg presets and save them to their mapBackgrounds uvar to be loaded using -mapload
if args.last('newmapbg') or args.last('deletemapbg') or args.last('savemap') or args.last('deletemap'):
 #First option is to create mapbg preset
 if args.last('newmapbg') or args.last('savemap'):
  mapName = (args.last('savemap') or args.last('newmapbg')).lower()
  mapBGState = {}
  formedMap = {mapName:mapBGState}
  for key, value in mapinfo.items():
   if value:
    if mapinfo.get('background')!= None:
     mapBGState["mapbg"] = mapinfo.get('background')
    mapBGState["mapsize"] = mapsize
    if mapinfo.get('options')!= None:
     mapBGState["mapoptions"] = mapinfo.get('options')
    if mapinfo.get('walls')!= None:
     mapBGState["walls"] = mapinfo.get('walls').split(', ')
    if mapinfo.get('objects')!= None:
     mapBGState["objects"] = mapinfo.get('objects').split('/')
  userMaps.update(formedMap)
  set_uvar("mapBackgrounds",dump_json(userMaps))
  desc.append(f"Created the map `{mapName}`")
 #Second option is to delete an already created map
 if args.last('deletemapbg') or args.last('deletemap'):
  argDeletemap = (args.last("deletemapbg") or args.last('deletemap')).lower()
  for searchMap in userMaps:
   if argDeletemap in searchMap.lower():
    userMaps.pop(searchMap)
    break
  set_uvar("mapBackgrounds",dump_json(userMaps))
  desc.append(f"Removed Map BG `{argDeletemap}`")
</drac2>
<drac2>
#Here we allow the user to save spell overlays in their mapOverlays uvar
if any(args.last(potentialArg) for potentialArg in ('newspell', 'saveoverlay', 'savespell', 'deletespell', 'deleteoverlay')):
 #First option is to create spell overlay
 if args.last('newspell') or args.last('savespell') or args.last('saveoverlay'):
  userOverlays = load_json(get('mapOverlays','{}'))
  for addNewspell in (args.get('saveoverlay') or args.get('newspell') or args.get('savespell')):
   if ":" in addNewspell:
    userOverlays.update({addNewspell.split(":")[0]:addNewspell.split(":")[1]})
   else:
     desc.append("You must separate the key and value with a colon when adding `-saveoverlay` entries.")
  set_uvar("mapOverlays",dump_json(userOverlays))
  desc.append(f"Created the overlay preset `{addNewspell.split(':')[0]}`")
 #second option is to delete an already created spell/overlay
 if args.last('deletespell') or args.last('deleteoverlay'):
  argDeletespell = (args.last("deletespell") or args.last('deleteoverlay')).lower()
  for searchDeletespell in userOverlays:
   if argDeletespell in searchDeletespell.lower():
    foundDeletespell = userOverlays.pop(searchDeletespell)
    break
   else:
    desc.append("Did not find the spell you were looking for.")
  set_uvar("mapOverlays",dump_json(userOverlays))
  desc.append(f"Removed Overlay `{searchDeletespell}`")
</drac2>

<drac2>
if c:
 # Read each combatants notes for their information
 for target in combat().combatants:
  # If they have a note, perse it into a dict
  if target.note and ':' in target.note:
   note=target.note
   note=note.split(" | ")
   note={x[0].lower():x[1] for x in [item.split(": ") for item in note]}
   out[target.name]=note
   # Check if we have any overlays attached to effects, and then if at effect exists
   for overNum in [""]+[str(x) for x in range(1,11)]:
    if out[target.name].get('effect'+overNum):
     checkEffect, checkEffectTarget = out[target.name].get('effect'+overNum).split(' / ')
     # If the effect (or the target it was on) are gone, remove the effect
     if not gt(checkEffectTarget) or not gt(checkEffectTarget).get_effect(checkEffect):
      _ = out[target.name].pop('effect'+overNum) if 'effect'+overNum in out[target.name] else None
      _ = out[target.name].pop('aim'+overNum) if 'aim'+overNum in out[target.name] else None
      _ = out[target.name].pop('overlay'+overNum) if 'overlay'+overNum in out[target.name] else None
      desc.append(f"""Overlay {overNum} removed from `{target.name}` because effect `{checkEffect}` no longer present{f" on {checkEffectTarget}" if checkEffectTarget!=target.name else ""}.""")
      desc.append("")
    # # If the overlay was -aim'd at a target, and if that aim target exists still
    # if out[target.name].get('aim'+overNum):
    #  aimTarget = out[target.name].get('aim'+overNum)
    #  aimTargetX = ''.join([i for i in aimTarget if i.isalpha()])
    #  aimTargetY = int(''.join([i for i in aimTarget if i.isdigit()]) or -1)
    #  if not (aimTargetX.upper() in alph[:mapX+2] and 0 < aimTargetY <= mapY and not gt(aimTarget)):
    #   _ = out[target.name].pop('effect'+overNum) if 'effect'+overNum in out[target.name] else None
    #   _ = out[target.name].pop('aim'+overNum) if 'aim'+overNum in out[target.name] else None
    #   _ = out[target.name].pop('overlay'+overNum) if 'overlay'+overNum in out[target.name] else None
    #   desc.append(f"""Overlay {overNum} removed from `{target.name}` because aim target `{aimTarget}` no longer present.""")
    #   desc.append("")
  elif target.note:
    note=target.note
    desc.append(f"Found a incorrectly formatted note on {target.name}, reformatted as a `-note`. ")
    out[target.name] = {"note": note.replace(':',' ').replace('|',' ')}
</drac2>
<drac2>
# Lets back up our map each time we run it, why not
# This will back the entire `out` dictionary containing everyones positions and states
# to a uvar named mapStates, with the current channels id added as s key inside it.
# This way you won't accidentally overwrite your backup with the backup from another channel

mapStates = load_json(get('mapStates','{}'))
prevBack = mapStates.get(chanid())
mapStates.update({chanid(): out})
set_uvar('mapStates', dump_json(mapStates))
# Clean up old uvars that are no longer needed
delete_uvar("mapState"+chanid())
delete_uvar("mapSize"+chanid())

# Then, if we have an undo in the arguments, we'll grab that backup (if it exists)
# and replace out out dict with it. We do this after we set the backup, so we can undo the undo
if args.last('undo') and prevBack:
  out = prevBack
  desc.append("> **Reloaded backup from last time this user ran a map command. The state this erased has now been set as their new backup.**")
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', combat().me.name if combat().me else None) and gt(args.last('t', combat().me.name if combat().me else None)):
  targ=gt(args.last('t', combat().me.name if combat().me else None))
  # If they don't have a note/location set, add them to the list
  if not out.get(targ.name):
   out[targ.name] = {}
  # If there is a -size arg, change their size
  if args.last('size'):
   size=args.last('size')[0].upper()
   # Confirm that the given size is valid before updating
   if size in siz:
    out[targ.name].update({"size":f"{size} ({SIZ[size]})"})
    # Display the change in size
    desc.append(f"Changing size of {targ.name} to {SIZ[size]} ({size})")
   # If the size is None, erase the size, setting them back to Medium
   elif args.last('size') in (None,"None","none"):
    if 'size' in out[targ.name]:
     _ = out[targ.name].pop('size')
    # Display the change in size
    desc.append(f"Resetting size of {targ.name} to Medium (M)")
</drac2>
<drac2> 
if c: 
 # If there is a -t argument given, and that target exists as a combatant, modify that target 
 if args.last('t', combat().me.name if combat().me else None) and gt(args.last('t', combat().me.name if combat().me else None)):  
  targ=gt(args.last('t', combat().me.name if combat().me else None))  
  # If they don't have a note/location set, add them to the list  
  if not out.get(targ.name):  
   out[targ.name] = {}  
  # If there is a -note arg, change their note  
  if args.last("note"): 
   newNote=args.last("note")  
   if args.last("note") in (None, "None", "none", True):  
    if 'note' in out[targ.name]:  
     _ = out[targ.name].pop('note') 
    # Display the change in the note  
    desc.append(f"Removing the note on {targ.name}.") 
   else:  
    out[targ.name].update({"note":f"{newNote}"})  
    # Display the change in size  
    desc.append(f"Setting note of {targ.name} to {newNote}")  
   # If the note is None, erase the note  
</drac2>  
<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', combat().me.name if combat().me else None) and gt(args.last('t', combat().me.name if combat().me else None)):
  # If there is a -color arg, change their color
  if args.last('color'):
   color = args.last('color').lower().strip('~') + " "
   color = color[:color.index(' ')]
   # Confirm that the given color is valid before updating
   # Is it one of our preset colors?
   if color in col:
    out[targ.name].update({"color":f"{color} ({COL[color]})"})
    # Display the change in color
    desc.append(f"Changing color of {targ.name} to {COL[color]} ({color})")
   # Or is it a hex code
   elif len(color) in (3, 6) and not color.strip("abcdef1234567890"):
    out[targ.name].update({"color":f"#{color.upper()}"})
    # Display the change in color
    desc.append(f"Changing color of {targ.name} to #{color.upper()}")
   # If the color is None, erase the color, setting them back to black
   elif args.last('color') in ("None","none"):
    _ = out[targ.name].pop('color')
    # Display the change in color
    desc.append(f"Resetting color of {targ.name} to Black")
</drac2>
<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', combat().me.name if combat().me else None) and gt(args.last('t', combat().me.name if combat().me else None)):
  # If there is a -height arg, change their height
  if args.last('height'):
   height = args.last('height')
   # If the height is none or 0, remove height from the target
   if height in ("None","none","0"):
    if 'height' in out[targ.name]:
     prevHeight = out[targ.name].pop('height')
     if prevHeight:
      desc.append(f"{targ.name} is no longer {['above','below'][int(prevHeight.strip(' ft.m'))<0] if prevHeight.strip(' -+ft.m').isdigit() else 'above'} the ground.")
   else:
    # Otherwise, set that targets height
    out[targ.name].update({'height':height})
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last('t', combat().me.name if combat().me else None) and gt(args.last('t', combat().me.name if combat().me else None)):
  # If there is a -token arg, change their token shortcode
  if args.last('token'):
   token = args.last('token')
   # If the token is none or 0, remove token from the target
   if token in ("None", "none", True, 'True', 'true'):
    prevToken = out[targ.name].pop('token')
    if prevToken:
     desc.append(f"{targ.name} is no longer using token {prevToken}.")
   else:
    # Otherwise, set that targets token
    out[targ.name].update({'token':token})
    desc.append(f"{targ.name} is now using the shortcode `{token}` as a token.")
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 # If no -t, default to current character
 if args.last('t', combat().me.name if combat().me else None) and gt(args.last('t', combat().me.name if combat().me else None)):
  prevLoc = out[targ.name].get('location')
  if args.last('move') and args.last('move') not in (True, 't', '-t', "TRUE") and (args.last('move')[0].isalpha() and args.last('move')[-1].isdigit()): 
   # Fix bad locations?
   if prevLoc == "TRUE":
    _ = out[targ.name].pop('location')
    prevLoc = None
   # Did they have a previous location? If so, lets calculate distance and draw a line
   if prevLoc and prevLoc.lower() != args.last("move", "").lower():
    # Split previous location from XY to X and Y
    prevLocX = ''.join(x for x in prevLoc if x.isalpha())
    prevLocY = ''.join(y for y in prevLoc if y.isdigit())
    if prevLocY and prevLocX:
      prevLocY = int(prevLocY)
      # Same as new location
      newLocX = ''.join(x.upper() for x in args.last('move') if x.isalpha())
      newLocY = int(''.join(y for y in args.last('move') if y.isdigit()))
      # Calculate the delta for X and Y between the two
      deltaX, deltaY = alph.index(prevLocX)-alph.index(newLocX), int(prevLocY)-int(newLocY)
      # Throw them in the pot with some pythag
      distanceT = int(round(sqrt((deltaX*deltaX)+(deltaY*deltaY)),0))*5
      # We want the positive delta (wish we had abs(), sigh)
      deltaX, deltaY = deltaX if deltaX>=0 else deltaX*-1,deltaY if deltaY>=0 else deltaY*-1
      # Doing 5ft diag's, the distance is just the higher delta
      distance = max(deltaX, deltaY)*5
      # Grab the targets new color if changed, old color if set, or default to dark violet
      colr = (args.last('color', out[targ.name].get('color','w')) + " ").strip("#~").lower()
      colr = colr[:colr.index(" ")]
      if len(colr) in (3, 6) and not colr.strip("abcdef1234567890"):
        colr = f"~{colr}"
      # Add the line to the overlay list
      overlays.append(f"*a{distanceT}{colr}{prevLocX}{prevLocY}{newLocX}{newLocY}")
      # Display the change in location
      desc.insert(0, f"Moving {targ.name} from {prevLoc} to {args.last('move').upper()} ({f'~{distanceT}' if get_svar('trueDistance') or get('trueDistance') else distance} ft.).")
   else:
    # Display the change in location
    desc.insert(0, f"Moving {targ.name} to {args.last('move').upper()}.")
   out[targ.name].update({"location": args.last('move').upper()})
</drac2>


<drac2>
# Overlay stuff
if c:
  for overNum in [""]+[str(x) for x in range(1,11)]:
   # Is the user trying to set an overlay?
   if args.last('over'+overNum):
    # If we have a target, but our -over arg is none, we're trying to delete our overlay
    if args.last('t') and gt(args.last('t')) and (args.last('over'+overNum) in ("none", "None")):
     _ = out[targ.name].pop('overlay'+overNum) if 'overlay'+overNum in out[targ.name] else None
     _ = out[targ.name].pop('aim'+overNum) if 'aim'+overNum in out[targ.name] else None
     desc.append(f"Removed overlay{' '+overNum if overNum else ''} linked to {targ.name}")
    else: # Split the input by commas
     overlay = args.last('over'+overNum).split(',')
     # First argument is always the shape, so lets pop it out
     oShape = overlay.pop(0).lower()

     # Are we attaching this to an effect?
     if args.last('effect'+overNum):
      # Split our effect up, in case we have a specified target
      effectName, effectTarget = (args.last('effect'+overNum).split('|')+[targ.name])[:2]
      effectTarget = gt(effectTarget)
      # Do we have a proper target, and does that target have our effect
      if effectTarget is not None and effectTarget.get_effect(effectName) is not None:
       effect = effectTarget.get_effect(effectName)

     # Are we aiming at someone?
     if args.last('aim'+overNum):
      # Split our aim up, in case we have a |split
      aim = (args.last('aim'+overNum).split('|')+[""])[:2]
      aimStick = (aim[1].lower() == "stick") or effect
      # Account for the user putting |stick on the wrong arg. Won't advertise this, as its unintended.
      if overlay[-1].endswith("|stick"):
        overlay[-1] = overlay[-1].replace("|stick", "")
        aimStick = True
      # If the target is, well, a target, grab its location
      for target in out:
       if aim[0].lower() in target.lower():
        aimPoint = out[target]['location']
        # Is our target larger than medium? If so, we need to offset to adjust
        if out[target].get('size',"M")[0] in "LHG":
         aimOffset = sizeOffset.get(out[target].get('size',"M")[0])
         aimTargX = ''.join(x for x in aimPoint if x.isalpha())
         aimTargY = int(''.join(y for y in aimPoint if y.isdigit()))
         aimTargX = alph[alph.index(aimTargX)+aimOffset]
         aimTargY += aimOffset
         aimPoint = f"{aimTargX}{aimTargY}"
        aimTarget = target
      # If the target wasn't a target, it was coordinates. Use them.
      if not aimPoint:
       aimPoint = aim[0]
       aimTarget = aim[0].upper()
     
     # Our basic structure, pre laid out
     currentOver = {"shape": "", "size": "", "width": ",", "color": "", "colorDesc": "", "loc": "", "eloc": ""}

     # This has all the information we need for our overlay[
     shapeDict = [{"type": "circle",       "name":"c",  "num": [3], "args": ("size", "color", "loc")},
                  {"type": "circletop",    "name":"ct", "num": [3], "args": ("size", "color", "loc")},
                  {"type": "circlecorner", "name":"co", "num": [3], "args": ("size", "color", "loc")},
                  {"type": "cone",         "name":"t",  "num": [4], "args": ("size", "color", "loc", "eloc")},
                  {"type": "line",         "name":"l",  "num": [5], "args": ("size", "width", "color", "loc", "eloc")},
                  {"type": "arrow",        "name":"a",  "num": [3], "args": ("color", "loc", "eloc")},
                  {"type": "square",       "name":"s",  "num": [3,4], "args": ("size", "color", "loc", "eloc")},
                  {"type": "squaretop",    "name":"st", "num": [3,4], "args": ("size", "color", "loc", "eloc")}]
     
     # Is the overlay valid?
     overValid = False

     # Did our user try to have the location linked to a target, but failed to supply a target?
     if "{targ}" in args.last('over'+overNum) and not (args.last('t') and gt(args.last('t'))):
      overlay = None
      desc.append(f"**Invalid overlay arguments.** {newline}Be sure to have a `-t`/`-aim{overNum}` if using `{targD}` and `{aimD}`")
     # Same for aiming it at something. If they failed to supply a -aim# 
     elif "{aim}" in args.last('over'+overNum) and not args.last('aim'+overNum):
      overlay = None
      desc.append(f"**Invalid overlay arguments.** {newline}Be sure to have a `-t`/`-aim{overNum}` if using `{targD}` and `{aimD}`")
     else:
      # Otherwise, lets loop through our possible overlays
      for shape in shapeDict:
       # Does it have a valid amount of arguments for the given shape?
       if oShape == shape.type and len(overlay) in shape.num:
        currentOver['shape'] = shape.name
        # Iterate over the needed args
        for index in range(len(overlay)):
         # If its a color, we need to account for both preset colors and hex codes
         if shape.args[index] == "color":
          overlaycolor = overlay[index].lower().strip('~') + " "
          overlaycolor = overlaycolor[:overlaycolor.index(' ')].strip()
          # If this is in our preset colors, use that
          if overlaycolor in col:
           currentOver[shape.args[index]] += overlaycolor
           currentOver['colorDesc'] += COL[overlaycolor]
          # Otherwise, check if its a hex code, either 3 or 6 digits
          elif len(overlaycolor) in (3, 6) and not overlaycolor.strip("abcdef1234567890"):
           currentOver[shape.args[index]] += f"~{overlaycolor}"
           currentOver['colorDesc'] += f"#{overlaycolor.upper()}"
         else:
          currentOver[shape.args[index]] += overlay[index]
        # Set the overlay for the map
        overlay = f"""{currentOver.shape}{currentOver.size}{currentOver.width.rstrip(',')}{currentOver.color}{currentOver.loc}{currentOver.eloc}"""
        # Set the description
        overdesc = f"""**{shape.type.replace("corner"," corner").replace("top"," top").title()} Overlay {overNum}**
                       - Color: `{currentOver.colorDesc}`
                       {f"- Size: `{currentOver.size} ft. " + ("radius`" if shape.type in "circletop" else "long`" if shape.type in "coneline" else "wide`") if shape.type != "arrow" else ""}
                       {f"- {'Top-left' if shape.type in ('circletop','square','squaretop') else 'Starting' if shape.type == 'cone' else 'Centered'}: `{currentOver.loc.upper()}`" if shape.type not in ("arrow", "line") else f"- Start: `{currentOver.loc.upper()}`"}
                       {f"- Width: `{currentOver.width.strip(', ')} ft.`" if shape.type == "line" else ""}
                       {f"- Aim: `{aimTarget or currentOver.eloc.upper()}`" if shape.type not in "circletop" and (aimTarget or currentOver.eloc) else ""}
                       {f"- Effect: `{effect.name}` on `{effectTarget.name}`" if effect else ""}"""
        overdesc = '\n'.join([i.strip() for i in overdesc.split('\n') if i.strip()])
        # If we made it this far, the overlay is valid, so we can break out of the loop
        overValid = True
        break
     if not overValid:
      overlay = None
     # If, after all the parsing above, we managed to get a proper overlay, continue
     if overlay:
      # Do we have a -aim? If so, replace {aim} with the aimPoint gathered before, and display who you're aiming at
      if aimPoint:
       overdesc = overdesc.replace('{aim}',aimPoint)
      # Are we attaching this overlay to a target?
      if args.last('t') and gt(args.last('t')):
       if not aimPoint or (aimPoint and aimStick) or effect:
        # If so, and no -aim (or -aim but also stick), lets attach it to the notes
        out[targ.name].update({"overlay"+overNum: overlay})
        if aimStick:
         out[targ.name].update({"aim"+overNum: aimTarget})
        if effect:
         out[targ.name].update({f"effect{overNum}": f"{effect.name} / {effectTarget.name}"})
       else:
        # If so, and -aim, lets *not* attach it to the notes, and just display it once
        targPoint = out[targ.name].get('location','A1')
        # Is our target Large or bigger? If so, adjust accordingly
        if out[targ.name].get('size',"M")[0] in "LHG":
         targOffset = sizeOffset.get(out[targ.name].get('size',"M")[0])
         TargX = ''.join(x for x in targPoint if x.isalpha())
         TargY = int(''.join(y for y in targPoint if y.isdigit()))
         TargX = alph[alph.index(TargX)+targOffset]
         TargY += targOffset
         targPoint = f"{TargX}{TargY}"
        overlays.append(overlay.replace("{targ}", targPoint).replace("{aim}", aimPoint))
       desc.append(overdesc.replace('{targ}', out[targ.name].get('location','A1')) + newline + f"- Attached: `{targ.name}`")
      else: 
       # Otherwise, lets just display it once
       overlays.append(overlay.replace("{aim}", aimPoint))
       desc.append(overdesc)
</drac2>

<drac2>
if c:
 for aimNum in [""]+[str(x) for x in range(1,11)]:
  # Is the user trying to change a -aim? 
  # Make sure they don't have a `-over`
  if args.last('aim'+aimNum) and not args.last('over'+aimNum):
   # Also make sure there is a valid target
   if (curTarg := args.last('t', combat().me.name if combat().me else None)) and (curTarg := gt(curTarg)):
    # And that target has an overlay, and an existing aim point
    if out[curTarg.name].get('overlay'+aimNum) and out[curTarg.name].get('aim'+aimNum):
     # If they used |stick, remove it, as its implied at this point
     aim = args.last('aim'+aimNum).split('|')[0]
     # If the aim target is, well, a target, grab its location     
     for target in out:
      if aim.lower() in target.lower():
       aimPoint = out[target]['location']
       # Is our aim target larger than medium? If so, we need to offset to adjust
       if out[target].get('size',"M")[0] in "LHG":
        aimOffset = sizeOffset.get(out[target].get('size',"M")[0])
        aimTargX = ''.join(x for x in aimPoint if x.isalpha())
        aimTargY = int(''.join(y for y in aimPoint if y.isdigit()))
        aimTargX = alph[alph.index(aimTargX)+aimOffset]
        aimTargY += aimOffset
        aimPoint = f"{aimTargX}{aimTargY}"
       aimTarget = target
     # If its not a target, use coordinates
     if not aimPoint:
      aimPoint = aim
      aimTarget = aim.upper()
     # Notify the user as to what happened
     desc.append(f"""Aim point for Overlay {aimNum} on {curTarg.name} changed from {out[curTarg.name].get('aim'+aimNum)} to {aimTarget}.""")
     # Update the aim target
     out[curTarg.name].update({"aim"+aimNum: aimTarget})
</drac2>

<drac2>
if c:
 # If there is a -t argument given, and that target exists as a combatant, modify that target
 if args.last("status"):
  if args.last('t') and gt(args.last('t')):
   targ = gt(args.last('t'))
   # If there is a -status arg, display all recorded map info on the target
   desc.append(f"**Status of {targ.name}**")
   if out.get(targ.name):
    for info in out[targ.name]:
     if info in ('aim', 'effect'):
      desc.append(f"- {info.title()}: `{out[targ.name][info]}`".replace(" / ", "` on target `"))
     else:
      desc.append(f"{info.title()}: `{out[targ.name][info]}`")
   else:
    desc.append("No information has been set yet.")
  else:
   if mapattach:
    desc.append(f"**Map settings (attached to {mapattach.name})**")
   for info in mapinfo:
    if info == "objects":
     objList = [f"{[objL[0] for objL in presetObjects.items() if obj[obj.index('$'):] in objL[1]][0]} at {obj[:obj.index('$')].upper()}" for obj in mapinfo[info].split("/")]
     desc.append(f"Objects: {' / '.join(objList) if len(objList) <= 10 else len(objList)}")
    else:
     desc.append(f"{info.title()}: `{mapinfo[info]}`")
    if info == "options":
     options = mapinfo[info]
     if options[0].isdigit():
      zoom = ""
      for char in options:
       if char.isdigit() or char == ".":
        zoom += char
       else:
        break
      desc.append(f" - Zoom set to {zoom}x")
     if 'd' in options:
      desc.append(f" - Dark Mode")
     if 'n' in options:
      desc.append(f" - Grid Hidden")
     if 'e' in options:
      desc.append(f" - Disable Border Opacity")
     if 'f' in options:
      desc.append(f" - Using alternative grid/token font")
     if 'c' in options:
      gsize = ""
      for char in options[options.index('c')+1:]:
       if char.isdigit():
        gsize += char
       else:
        break
      desc.append(f" - Grid size adjusted to {gsize} px")
     if 'h' in options:
      gtrans = ""
      for char in options[options.index('h')+1:]:
       if char.isdigit():
        gtrans += char
       else:
        break
      desc.append(f" - Grid transparancy adjusted to {gtrans}%")
     if 'o' in options:
      offset = ""
      for char in options[options.index('o')+1:]:
       if char.isdigit() or char == ":":
        offset += char
       else:
        break
      desc.append(f" - Background Offset adjusted by {offset.replace(':', 'x')} px")
  desc.append("")
</drac2>

<drac2>
#Load user saved token list
if args.last('savetoken') or args.last('deletetoken'):
 if args.last('savetoken'):
  for addNewToken in args.get('savetoken'):
   if ":" in addNewToken:
    userTokens.update({addNewToken.split(":")[0]:addNewToken.split(":")[1]})
   else:
    desc.append("You must separate the key and value with a colon when adding `-savetoken` entries.")
  set_uvar("mapTokens",dump_json(userTokens).lower())
  desc.append(f"Created the Token `{addNewToken.split(':')[0]}`")
 if args.last('deletetoken'):
  argToken = args.last("deletetoken").lower()
  userTokens.pop(argToken)
  set_uvar("mapTokens",dump_json(userTokens).lower())
  desc.append(f"Removed Token `{argToken}`")
</drac2>

<drac2>
if c:
 for massTarg in args.get('t'):
  mTarg, mMove, mSize, mColor, mToken = (massTarg.split('|') + ["","","",""])[:5]
  if (mTarg := gt(mTarg)):
   # If they don't have a note/location set, add them to the list  
   if not out.get(mTarg.name):  
    out[mTarg.name] = {}  
   if mMove:
    prevLoc = out[mTarg.name].get('location')
    # Did they have a previous location? If so, lets calculate distance and draw a line
    if prevLoc and prevLoc.lower() != mMove.lower():
     # Split previous location from XY to X and Y
     prevLocX = ''.join(x for x in prevLoc if x.isalpha())
     prevLocY = ''.join(y for y in prevLoc if y.isdigit())
     if prevLocY and prevLocX:
       prevLocY = int(prevLocY)
       # Same as new location
       newLocX = ''.join(x.upper() for x in mMove if x.isalpha())
       newLocY = int(''.join(y for y in mMove if y.isdigit()))
       # Calculate the delta for X and Y between the two
       deltaX, deltaY = alph.index(prevLocX)-alph.index(newLocX), int(prevLocY)-int(newLocY)
       # Throw them in the pot with some pythag
       distanceT = int(round(sqrt((deltaX*deltaX)+(deltaY*deltaY)),0))*5
       # We want the positive delta (wish we had abs(), sigh)
       deltaX, deltaY = deltaX if deltaX>=0 else deltaX*-1,deltaY if deltaY>=0 else deltaY*-1
       # Doing 5ft diag's, the distance is just the higher delta
       distance = max(deltaX, deltaY)*5
       # Grab the targets new color if changed, old color if set, or default to dark violet
       colr = (args.last('color', out[mTarg.name].get('color','w')) + " ").strip("#~").lower()
       colr = colr[:colr.index(" ")]
       if len(colr) in (3, 6) and not colr.strip("abcdef1234567890"):
         colr = f"~{colr}"
       # Add the line to the overlay list
       overlays.append(f"*a{distanceT}{colr}{prevLocX}{prevLocY}{newLocX}{newLocY}")
       # Display the change in location
       desc.insert(0, f"Moving {mTarg.name} from {prevLoc} to {mMove.upper()} ({f'~{distanceT}' if get_svar('trueDistance') or get('trueDistance') else distance} ft.).")
    else:
     # Display the change in location
     desc.insert(0, f"Moving {mTarg.name} to {mMove.upper()}.")
    out[mTarg.name].update({"location":mMove.upper()})
   if mSize:
    size=mSize[0].upper()
    # Confirm that the given size is valid before updating
    if size in siz:
     out[mTarg.name].update({"size":f"{size} ({SIZ[size]})"})
     # Display the change in size
     desc.append(f"Changing size of {mTarg.name} to {SIZ[size]} ({size})")
   if mColor:
    color = mColor.lower().strip('~') + " "
    color = color[:color.index(' ')]
    # Confirm that the given color is valid before updating
    # Is it one of our preset colors?
    if color in col:
     out[mTarg.name].update({"color":f"{color} ({COL[color]})"})
     # Display the change in color
     desc.append(f"Changing color of {mTarg.name} to {COL[color]} ({color})")
    # Or is it a hex code
    elif len(color) in (3, 6) and not color.strip("abcdef1234567890"):
     out[mTarg.name].update({"color":f"#{color.upper()}"})
     # Display the change in color
     desc.append(f"Changing color of {mTarg.name} to #{color.upper()}")
   if mToken:
    token = mToken
    out[mTarg.name].update({'token':token})
    desc.append(f"{mTarg.name} is now using the shortcode `{token}` as a token.")
   if args.last('loadtoken'):
    foundTokenload = None
    argsTokenload = args.last('loadtoken').lower()
    for searchTokenload in userTokens:
     if argsTokenload in searchTokenload.lower():
      foundTokenload = userTokens.get(searchTokenload)
      desc.append(f"Loaded token `{searchTokenload}`.")
      out[mTarg.name].update({'token':foundTokenload}) 
      break
</drac2>



<drac2>
if args.last('tokenimport'):
 tokenimport = args.last('tokenimport').encode()

 b64_index = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

 ascii_bin_str = ""
 tokenoutput = ""

 for c in tokenimport:
     ascii_bin_str += f'{c:08b}'  # construct a binary-representation string

 numChunks = int(len(ascii_bin_str) / 6)  # how many 6
 for i in range(numChunks):
     chunk = ascii_bin_str[i * 6: (i + 1) * 6]
     tokenoutput += b64_index[int(chunk, base=2)]

 leftoverBits = len(ascii_bin_str) % 6  # since the input was a multiple of 8, this must be 2 or 4
 if leftoverBits > 0:
     leftover = ascii_bin_str[leftoverBits * -1:]
     if leftoverBits == 2:
         tokenoutput += b64_index[int(leftover+('0' * 4), base=2)]
         tokenoutput += ('=' * 2)
     elif leftoverBits == 4:
         tokenoutput += b64_index[int(leftover+('0' * 2), base=2)]
         tokenoutput += '='

 desc.append(f"Token shortcode for `{args.last('tokenimport')}` can be found at [This Link](https://token.otfbm.io/meta/{tokenoutput}){newline}{newline}You can attach that shortcode to a target with `-token [shortcode]`")
</drac2>

<drac2>
if c:
 # If theres a -mapsize, -bg, -options, -view, -attach, -view, -wall, -deletewall, -object, -deleteobject, -loadmap, -savebattle, -deletebattle, or -loadbattle  - arg, process that and add/replace the effect
 if any(args.last(thisArg) for thisArg in ('mapsize', 'mapbg', 'bg', 'mapoptions', 'options', 'mapview', 'view', 'mapattach', 'attach', 'wall', 'deletewall', 'object', 'deleteobject', 'loadmap', 'savebattle', 'deletebattle', 'loadbattle')):
  # If the new mapsize is different from the old one, update and display
  if mapsize != args.last('mapsize', mapsize):
   mapSplitX, mapSplitY = args.last('mapsize', mapsize).lower().split('x')
   mapSplitX = min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize)
   mapSplitY = min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize)
   mapsize = f"{mapSplitX}x{mapSplitY}"
   desc.append(f"Map size changed to `{mapsize}`")
  # If the new mapbg is different from the old one, update and display
  if mapbg != args.last('mapbg', args.last('bg', mapbg)):
   if args.last('mapbg', args.last('bg')) in ('none', 'None', 'reset'):
    mapbg = ""
    desc.append(f"Map background removed")
   else:
    mapbg = args.last('mapbg', args.last('bg', mapbg))
    desc.append(f"Map background changed to `{mapbg}`")
  if mapoptions != args.last('mapoptions', args.last('options', mapoptions)):
  # If the new mapoptions are different from the old ones, update and display
   if args.last('mapoptions', args.last('options')) in ('none', 'None', True, 'true', 'True', None):
    mapoptions = ""
    desc.append(f"Map options reset")
   else:
    mapoptions = args.last('mapoptions', args.last('options', mapoptions))
    desc.append(f"Map options changed to `{mapoptions}`")
    if mapoptions[0].isdigit():
     zoom = ""
     for char in mapoptions:
      if char.isdigit() or char == ".":
       zoom += char
      else:
       break
     desc.append(f" - Zoom set to {zoom}x")
    if 'd' in mapoptions:
     desc.append(f" - Dark Mode")
    if 'n' in mapoptions:
     desc.append(f" - Grid Hidden")
    if 'e' in mapoptions:
     desc.append(f" - Disable Border Opacity")
    if 'f' in mapoptions:
     desc.append(f" - Using alternative grid/token font")
    if 'c' in mapoptions:
     gsize = ""
     for char in mapoptions[mapoptions.index('c')+1:]:
      if char.isdigit():
       gsize += char
      else:
       break
     desc.append(f" - Grid size adjusted to {gsize} px")
    if 'h' in mapoptions:
     gtrans = ""
     for char in mapoptions[mapoptions.index('h')+1:]:
      if char.isdigit():
       gtrans += char
      else:
       break
     desc.append(f" - Grid transparancy adjusted to {gtrans}%")
    if 'o' in mapoptions:
     offset = ""
     for char in mapoptions[mapoptions.index('o')+1:]:
      if char.isdigit() or char == ":":
       offset += char
      else:
       break
     desc.append(f" - Background Offset adjusted by {offset.replace(':', 'x')} px")
  if mapview != args.last('mapview', args.last('view', mapview)):
   # Do they want to reset the map view?
   if args.last('mapview', args.last('view')).lower() in ('reset', 'none'):
    mapviewlocation = mapviewsize = ""
    desc.append(f"""Map view reset to default `{mapsize}`.""")
   else:
    # If the new mapview are different from the old one, update and display
    mapview = args.last('mapview', args.last('view', mapview))
    mapviewlocation = mapview.split(':')[0]
    mapviewsize = mapview.split(':')[1]
    if mapviewsize[0].isdigit():
     mapSplitX, mapSplitY = mapviewsize.lower().split('x')
     mapX = min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize)
     mapY = min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize)
    else:
     locX = alph.index(''.join(x.upper() for x in mapviewlocation if x.isalpha()))
     locY = int(''.join(y for y in mapviewlocation if y.isdigit()))
     mapX = alph.index(''.join(x.upper() for x in mapviewsize if x.isalpha()))
     mapY = int(''.join(y for y in mapviewsize if y.isdigit()))
     mapX = mapX - locX + 1
     mapY = mapY - locY + 1
    mapviewsize = f"{mapX}x{mapY}"
    desc.append(f"Map view changed to `{mapview if f'{mapviewlocation}:{mapsize}'==mapview else f'{mapview} ({mapviewsize})'}`")
  #If there is a -wall
  if args.last('wall'):
   if args.last('wall') in ('none', 'None', True, 'true', 'True'):
    walls = []
    desc.append(f"Walls reset.")
   else:
    inputtedWalls = args.last('wall')
    walls.append(inputtedWalls)
    desc.append(f"Wall added: `{inputtedWalls}`")
  if args.last('deletewall'):
   inputtedWalls = args.last('deletewall')
   remWalls = [wall for wall in walls if inputtedWalls.lower() != wall.lower()]
   if len(walls) != len(remWalls):
    desc.append(f"Wall removed: `{inputtedWalls}`")
    walls = remWalls
   else:
    desc.append(f"Could not find wall: `{inputtedWalls}`")
  #If there is a -object call
  if args.last('object'):
   if args.last('object') in ('none', 'None', True, 'true', 'True'):
    objects = []
    desc.append(f"Objects reset")
   else:
    foundObject = ""
    argsObject = args.last("object").lower().split(":")
    for object in presetObjects:
     if argsObject[1] in object.lower():
      foundObject = presetObjects[object]
      break
    if foundObject:
     objectLocation = argsObject[0]
     loadedObject=objectLocation+foundObject
     objects.append(loadedObject)
     desc.append(f"Object added `{object}:{loadedObject}`")
    else:
     desc.append("Could not find object")
  if args.last('deleteobject'):
   foundObject = "There is no object by that name"
   argsObject = args.last("deleteobject").lower().split(":")
   for object in presetObjects:
    if argsObject[1] in object.lower():
     foundObject = presetObjects[object]
     break
   objectLocation = argsObject[0]
   loadedObject=objectLocation+foundObject
   objects.remove(loadedObject)
   desc.append(f"Object `{object}:{loadedObject}` was removed")
  if args.last('savebattle'):
   argsBattle = args.last('savebattle')
   mapBGState = {}
   for key, value in mapinfo.items():
    if value:
     if mapinfo.get('background')!= None:
      mapBGState["mapbg"] = mapinfo.get('background')
     mapBGState["mapsize"] = mapsize
     if mapinfo.get('options')!= None:
      mapBGState["mapoptions"] = mapinfo.get('options')
     if mapinfo.get('walls')!= None:
      mapBGState["walls"] = mapinfo.get('walls').split(', ')
     if mapinfo.get('objects')!= None:
      mapBGState["objects"] = mapinfo.get('objects').split('/')
     if mapinfo.get('view')!= None:
      mapBGState["view"] = mapinfo.get('view')
     break
   savedBGState = {"mapattach":mapBGState}
   savedBGState.update(out)
   savedBattle = {argsBattle:savedBGState}
   userBattles.update(savedBattle)
   set_uvar("mapBattles",dump_json(userBattles))
   desc.append(f"Saved the battle `{argsBattle}`")
  if args.last('deletebattle'):
   inputtedBattle = args.last('deletebattle')
   foundBattle = None
   for battle in userBattles:
    if inputtedBattle in battle.lower():
     foundBattle = userBattles.pop(battle)
     set_uvar("mapBattles", dump_json(userBattles))
     desc.append(f"Deleted the battle `{inputtedBattle}`")
     break
   if not foundBattle:
    desc.append(f"Did not find the battle you were looking for")
  if args.last('loadbattle'):
   argsBattle = args.last('loadbattle').lower()
   foundBattle = ""
   for searchBattle in userBattles:
    if argsBattle in searchBattle.lower():
     foundBattle = userBattles[searchBattle]
     for searchCombatant in foundBattle:
      if searchCombatant not in ("mapattach"):
       foundCombatants = dict(list(foundBattle.items())[1:])
       currentCombatants = [combat().get_combatant(name)]
       if all([combat().get_combatant(searchCombatant) for searchCombatant in foundCombatants.keys()]):
        out = dict(list(foundBattle.items())[1:])
        foundMapload = foundBattle["mapattach"]
        if "mapbg" in foundMapload:
         mapbg = foundMapload["mapbg"]
        mapsize = foundMapload["mapsize"]
        if "mapoptions" in foundMapload:
         mapoptions = foundMapload["mapoptions"]
        if "walls" in foundMapload:
         walls = foundMapload["walls"]
        if "objects" in foundMapload:
         objects = foundMapload["objects"]
        if "view" in foundMapload:
         mapviewlocation, mapviewsize = foundMapload["view"].replace('::',':').split(':')
        desc.append(f"Loaded the battle `{argsBattle}`")
        break
       else:
        missingCombatants = [combatants for combatants in foundCombatants if not combat().get_combatant(combatants)]
        desc.append(f'You need to add the Combatant{"s" if len(missingCombatants) > 1 else ""} `{", ".join(missingCombatants)}` to combat first to load the battle')
        break
  # If there is a -mapattach, and its a valid target in init
  if args.last('mapattach', args.last('attach')) and gt(args.last('mapattach', args.last('attach'))):
   # First check if there is an existing mapattach, and if its the same as the new one, then remove their map effect
   if typeof(mapattach)=="SimpleCombatant" and gt(args.last('mapattach', args.last('attach'))).name != mapattach.name:
    mapattach.remove_effect('map')
   # Then, set the new mapattach
   mapattach = gt(args.last('mapattach', args.last('attach')))
  # If theres mapattach set, and they currently have a map effect, remove it
  if mapattach and mapattach.get_effect('map'):
   mapattach.remove_effect('map')
  # Format everything appropriately
  setMapView = f"{mapviewlocation}:{mapviewsize}"
  neweffect = f"""{f"Size: {mapsize}" if mapsize else ""}{f" ~ Background: {mapbg}" if mapbg else ""}{f" ~ Options: {mapoptions}" if mapoptions else ""}{f" ~ Walls: {', '.join(walls)}" if walls else""}{f' ~ Objects: {"/".join(objects)}' if objects else ""}{f" ~ View: {setMapView}" if setMapView.strip(':') else ''}""".strip(" ~")
  # If mapattach exists, apply the new effect, and display
  if mapattach:
   mapattach.add_effect('map', f"""-attack "||{neweffect}" """)
   desc.append(f"Map settings attached to `{mapattach.name}`")
  # Otherwise, show that it was changed, but not saved
  else:
   # Look for a combatant named DM or Map, auto attach
   for maptarg in ("map", "dm", "lair"):
     if c.get_combatant(maptarg):
       mapattach = c.get_combatant(maptarg)
       mapattach.add_effect('map', f"""-attack "||{neweffect}" """)
       desc.append(f"""Autoattached map settings to {mapattach.name}""")
       break
   else:
    desc.append("Map settings changed, but no map attach target was found. Settings not saved.")
</drac2>

<drac2>
if c:
 # Parse the collected notes and information into the format readable by otfbm.com
 people = []
 for target in out:
  tLocation = out[target].get('location')
  tSize = out[target].get('size','M')[0].upper()
  tColor = out[target].get('color', 'b' if '/' in gt(target).hp_str() else 'r') + " "
  tColor = tColor[:tColor.index(" ")].strip('#')
  tToken = out[target].get('token')
  # Account for hex colors
  if len(tColor) in (3, 6):
   tColor = f"~{tColor}".upper()
  tName = target.translate(str.maketrans(' ', '_', nameStrip))
  # Only display if they have a location
  if tLocation:
    people.append(f"{tLocation}{tSize}{tColor}-{tName}{f'~{tToken}' if tToken else ''}")
  # Do they have a height set? If so, display it
  if out[target].get('height'):
   desc.append(f"{target} is currently {out[target].get('height').strip('-+')} ft. {['above','below'][int(out[target].get('height').strip(' ft.m'))<0] if out[target].get('height').strip(' -+ft.m').isdigit() else 'above'} the ground.")
  # Do they have overlays?
  for overNum in [""]+[str(x) for x in range(1,11)]:
    # Ensure we're not grabbing the previous overlays aim point
    targAimPoint = ""
    if out[target].get('overlay'+overNum):
     targPoint = out[target].get('location','A1')
     # Is our target Large or bigger? If so, adjust accordingly
     if out[target].get('size',"M")[0] in "LHG":
      targOffset = sizeOffset.get(out[target].get('size',"M")[0])
      TargX = ''.join(x for x in targPoint if x.isalpha())
      TargY = int(''.join(y for y in targPoint if y.isdigit()))
      TargX = alph[alph.index(TargX)+targOffset]
      TargY += targOffset
      targPoint = f"{TargX}{TargY}"
     # If the target has an aim point set
     if out[target].get('aim'+overNum):
      for aimTarget in out:
       # We need to check to see if they were targetting a... target
       if out[target].get('aim'+overNum).lower() in aimTarget.lower():
        targAimPoint = out[aimTarget]['location']
        # Is our aimTarget larger than medium? If so, we need to offset to adjust
        if out[aimTarget].get('size',"M")[0] in "LHG":
         targAimOffset = sizeOffset.get(out[aimTarget].get('size',"M")[0])
         targAimTargX = ''.join(x for x in targAimPoint if x.isalpha())
         targAimTargY = int(''.join(y for y in targAimPoint if y.isdigit()))
         targAimTargX = alph[alph.index(targAimTargX)+targAimOffset]
         targAimTargY += targAimOffset
         targAimPoint = f"{targAimTargX}{targAimTargY}"
       # If the aimTarget wasn't a target, it was coordinates. Use them.
       if not targAimPoint:
        targAimPoint = out[target].get('aim'+overNum).upper()
     # Add each targets overlay to the overlays list
     overlays.append(out[target].get('overlay'+overNum).replace("{targ}", targPoint).replace("{aim}", targAimPoint).strip("*"))
 # Reconvert all of our map information back into the readable note format
 dataout={x:' | '.join([f"{item[0].title()}: {item[1]}"for item in out[x].items()])for x in out}
 # Then set everyones note again. Kinda a chainsaw instead of a scalpel situation here.
 for target in dataout:
  gt(target).set_note(dataout[target])
 # If a 'clear' arg is given, clear the entire map (clears everyones notes)
 if args.last('clear'):
  [i.set_note(None)for i in combat().combatants]
  people=[]
  overlays=[]
 # Join everything together and display the map if we aren't displaying the help
 overlays = [f"*{overlay.strip('*')}" for overlay in overlays]
 if not any(args.get(arg) for arg in ('?', 'help', 'spelllist', 'spellbook', 'maplist', 'bglist', 'backgroundlist', 'viewlist', "battlelist")):
  finalMap = f"""{map}{mapsize}{f"/{mapviewlocation}:{mapviewsize}" if mapviewsize and mapviewlocation else ""}/{f'_{"_".join(walls)}/' if walls else ""}{f"@{mapoptions}/"if mapoptions else""}{f'{"/".join(objects)}/' if objects else ""}{'/'.join(people+overlays)}?a=1&cid={ctx.channel.id}&sid={ctx.guild.id}&uid={ctx.author.id}{"&d=1" if testVersion else ""}{f"&bg={mapbg}" if mapbg else ""}"""
  return f"""{'' if args.last('silent') else f'-image "{finalMap}"'} -f "[Map]({finalMap})" """ + (f"""  -desc "{newline.join(desc)}"  """ if desc else "")
</drac2>

<drac2>

colorSplit = [list(COL.items())[i:i+2] for i in range(0, len(COL), 2)]
colorOut = []
for color1, color2 in colorSplit:
  colorOut.append(f"""{color1[0]:<3}- {color1[1]:<6} | {color2[0]:<3}- {color2[1]:<6}""")

helpindex = f"""
-f "Help Index|`!map help` - Basic Commands and Tokens
`!map help <manage|dm>` - Visual Options and Map Views
`!map help <over|spells>` - Overlays and Spells
`!map help <walls|doors|objects>` - Walls, Doors and Objects

**Additional help**
Check our [Documentation website](http://docs.otfbm.com/) to find every command and argument explained in detail and with practical examples.

**Support Us**
You can support OTFBM on [Patreon](https://www.patreon.com/otfbm) and this alias at [Ko-Fi](https://ko-fi.com/croebh)"
"""
colorhelp = f"""-f "Valid Colors|```{newline.join(colorOut)}```You can also provide 3 or 6 digit hex codes, like `D73` or `D2773f`|inline" """
sizehelp = f"""-f "Valid Sizes|```{newline.join([f"{x[0]} - {x[1]}" for x in SIZ.items()])}```|inline" """


# Are we trying to display the spelllist?
if args.get('spelllist') or args.get('spellbook'):
 # Only grab the page selected, default to first
 if spellPagin:
  spellPage = f"""-desc "{newline.join(spellPagin[ min(len(spellPagin),args.last('page', 1, int)-1)] )}" """
 else:
  spellPage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return spellPage + f"""-title "Wait, how do you Spell that again?"
                        -f "Add your own overlays/spells| You can add your own overlays/spells by running the command `-saveoverlay <overlay/spellname>:<overlay>`"
                        -f "`{targD}` and `{aimD}`| These will be replaced by the `-t` target and `-aim` target respectively."  """
# Are we trying to display the maplist?
elif args.get('maplist') or args.get('bglist') or args.get('backgroundlist'):
 # Only grab the page selected, default to first
 if mapPagin:
  mapPage = f"""-desc "{newline.join(mapPagin[ min(len(mapPagin),args.last('page', 1, int)-1)] )}" """
 else:
  mapPage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return mapPage + f"""-title "Where are we at on the map?"
                        -f "Add your own maps| You can add your own maps by running the command `-savemap <mapname>`"  """
elif args.get('viewlist'):
 # Only grab the page selected, default to first
 if presetPagin:
  presetPage = f"""-desc "{newline.join(presetPagin[ min(len(presetPagin),args.last('page', 1, int)-1)] )}" """
 else:
  presetPage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return presetPage + f"""-title "Say hello to my little preset"
                        -f "Add your own `-mapview` presets| You can create your own presets by running the command `-saveview <presetname>,<mapview preset>`"  """
elif args.get('tokenlist'):
     # Only grab the page selected, default to first
 if tokenPagin:
  tokenPage = f"""-desc "{newline.join(tokenPagin[ min(len(tokenPagin),args.last('page', 1, int)-1)] )}" """
 else:
  tokenPage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return tokenPage + f"""-title "Token for your thoughts"  """
elif args.get('battlelist'):
 # Only grab the page selected, default to first
 if battlePagin:
  battlePage = f"""-desc "{newline.join(battlePagin[ min(len(battlePagin),args.last('page', 1, int)-1)] )}" """
 else:
  battlePage = f"""-desc "No results found{f" for search term `{args.last('search')}`" if args.last('search') else ''}." """
 # Add some pizazz
 return battlePage + f"""-title "Knowing is half the battle"  """
# If we're not in combat, or "?" or "help" are given as arguments, display the help
elif not c or args.get('?') or args.get('help'):
 if any(args.last(potentialArg) for potentialArg in ('overlay', 'over', 'overlays', 'spell', 'spells')):
  help = f"""-title "Maps: overlays and spells"
            -desc "{["Bro","Broski","Brotein","Brosicle","Broseph","Brotastic","Han Brolo","Broba Fett","Brotato Chip","Broseidon","Brochacho","Broebh"][randint(12)]}, I'm so Over this!

            Check our [Overlays Guide](http://docs.otfbm.com/#/guides-overlays) for detailed explanations of the commands below. Note: radius, size, length and width are in feet. For valid colours see below.

            **__Basic Overlays__**
            `-over circle,<radius>,<color>,<center>` - Draws a circle centered on a coordinate.
            `-over circletop,<radius>,<color>,<topleft>` - Draws a circle from the top left coordinate.
            `-over circlecorner,<radius>,<color>,<topleftcorner>` - Draws a circle centered on the top left corner of a coordinate.
            `-over cone,<size>,<color>,<start>,<end>` - Draws a cone with start and aim coordinates.
            `-over line,<length>,<width>,<color>,<start>,<end>` - Draws a line with start and end coordinates.
            `-over arrow,<color>,<start>,<end>` - Draws an arrow with start and end coordinates.
            `-over square,<size>,<color>,<topleft>[,end]` - Draws a square from a top left coordinate. Optional: Aim at a coordinate to rotate the square.
            `-over squaretop,<size>,<color>,<topleft>,<end>` - Draws a square from a top left coordinate, but when aimed the pivot point is the top left corner.

            **__Other commands__**
            `-over [args] -t <target>` - Your overlay keeps disappearing? Without a `-t`, an overlay defaults to showing only once. This means the next time you run `!map` it won't be there. Target a combatant to stick an overlay to it and it'll remain visible until removed.
            `-over none -t <target>` - Removes an overlay attached to a target.
            `-saveoverlay <name>:<overlay>` - Saves a overlay, in the `spellbook`(see bellow), for quick access. Example: `-saveoverlay Explosion:circle,30,r,J5`
            `-deleteoverlay <name>` - Deletes a saved overlay.            

            **__Overlays as Spells__**
            `!map spellbook` - Lists all ready-made spell overlays.
            `-spell <spellname>` - Draws the spell, from the overlays' spellbook, on the map."

            -f "_ _|**__Aiming and Connecting Overlays__**
            `-aim [target]` - Allows you to aim an overlay at a target. Use `{aimD}` in the `-over` command in order grab it. Works on both locations (`A3`) and targets (`OR3`). If a `-t` is provided as well, it won't attach the overlay to them. Can be used to move an existing aimed overlay.
            `-aim [target]|stick` - Same as above, but it *will* attach the overlay to a `-t` if provided, and will attach the `-aim` info as well.
            `-effect \"<effect>[|effectTarget]\"` - Allows you to 'connect' an overlay to an init effect on a target. When the effect or target are no longer present, the overlay will be removed. See `!help init effect` for details on creating them.
            You can replace coordinates with `{targD}` to have those coordinates linked with the `-t` target. For example, `-over circle,30,b,{targD} -t OR1` would cause it to be positioned on top of OR1, regardless of where they move.

            If your `-aim` or `-t` is a Large or bigger monster, the alias will try to adjust for the size difference."

            -f "_ _|**__Multiple Overlays__**
            You can create multiple overlays at a time by appending a number, from 1 to 9, to the end of the `-over`/`-aim`/`-effect`/`-spell` argument. For example: `-over1 [args] -over2 [args]`
            Note: `-over2`/`-spell2` will be linked to `-aim2` and `-effect2`, and so on, for each overlay."                       
            """.replace(" "*11,"") + colorhelp
 elif any(args.last(potentialArg) for potentialArg in ('map', 'manage', 'options', 'dm', 'gm')):
  help =  """-title "Maps: Visual Options" 
             -desc "Wait, were we in the dungeon or the pub?

             **__Allow the Map Settings to Save__**
             The map attaches these settings automatically to any combatant in the initiative order that's named `DM`, `Map`, or `Lair`. Attaching a map allows every change that's made to it to be saved. We recommend adding a dedicated combatant for this, instead of a player or a monster, to prevent the map from vanishing when a player exits combat, or a monster is killed. Regardless, you can manually attach the map to any other combatant by running `-attach <target>`.

             If these settings are run when they aren't attached to a `-attach` target, then the change will be temporary, and will be switched back to your default the next time you run the `!map` command.

             You can view the current map settings by running `!map status`

             **__Map Size and Background Image__**
             `-mapsize <size>` - Sets the size of the map. Example: `-mapsize 20x20`
             `-bg <url>` - Imports an image to use as background. Use `-options c` / `o`, see below, to scale / offset the image to match the grid.
             `-bg none` - Removes the background.

             **__Ready-Made Maps__**
             `!map maplist` - Lists all ready-made maps.
             `-savemap <name>` - Saves a map with your current background, options, walls, objects for quick access. Uses your `mapBackgrounds` uvar.
             `-loadmap <name>` - Loads a saved map.
             `-deletemap <name>` - Deletes a saved map."

             -f "_ _|**__Map views__**
             `-view <coordinate>:<coordinate>` - Focuses on a portion of the map. Example: `-view A3:K12`
             `-view <coordinate>:<gridsize>` - Focuses on a portion of the map, but with a specified size instead of an end location. Example: `-view A3:4x10`
             `-view reset` - Returns to full view.

             **__Saving, Loading and Deleting views__**
             `!map viewlist` - Lists all saved views.
             `-saveview <name>,<coordinate>:<coordinate>` - Saves a view, for quick access. Example: `-saveview Ambush,K5:Z15`
             `-loadview <name>` - Loads a saved view.
             `-deleteview <name>` - Deletes a saved view.

             **__Saving, Loading and Deleting Battles__**
             `!map battlelist` - Lists all saved battles.
             `-savebattle <name>` - Saves a battle, for quick access. This will include your map settings, as well as combatants and any overlays that are attached to them.
             `-loadbattle <name>` - Loads a saved battle.
             `-deletebattle <name>` - Deletes a saved battle."

             -f "_ _|**__Interface Options__**
             `-options [args]` - Changes visual options using the following arguments:
             `z<#>` - Changes the map's resolution, range 1-3, accepts fractions. The higher the value the larger the map will be, allowing to zoom in without loosing image quality. Example: `-options z1.5`
             `d` - Dark mode
             `h<#>` - Sets the grid's transparancy, range 1-99. Example: `-options h10` would set it to 10%.
             `n` - Hides the grid.
             `e` - Everything outside the map's edges becomes invisible.
             `f` - Use alternative grid/token font
             `c<#>` - Sets the grid's unit size (in px). Default: 60.
             `o<#>:<#>` - Offsets the background image (in px). Example: `-options o20:40` would offset it 20px down and 40px to the right.
             Run `-options` without a specific argument to revert its change. With no arguments it'll reset every change. 
             You can set multiple settings at a time. If you do, zoom should be your first option, if you're setting it. Example: `-options z2n` would set zoom to 2 and hide the grid."

             -f "_ _|**__Backup / Restore__**
             `!map undo` - Reverts all combatants to the state of last time you ran a `!map` command. You only have one undo, and running `!map undo` a second time undoes it. This information is kept in the `mapStates` uvar, keyed to the channel ID."

             -f "_ _|**__Server Settings__**
             To set defaults for your server, simply create an svar named `mapDefaults`, containing a dict as follows, filling in the information as needed:
             `!svar mapDefaults {\\\"size\\\":\\\"\\\", \\\"background\\\":\\\"\\\", \\\"options\\\":\\\"\\\"}`
             
             You can also copy your `mapOverlays`, `mapPresets`, `mapTokens`, `mapBattles`, `trueDistance` uvars into svars, and they'll be set/available for the whole server."
  """
 elif any(args.last(potentialArg) for potentialArg in ('walls', 'wall', 'door', 'doors', 'object', 'objects')):
  help = f"""-title "Map: Walls, Doors and Objects"
             -desc "**__Allow the Walls and Objects to Save__**
             The map attaches these walls and objects automatically to any combatant in the initiative order that's named `DM`, `Map`, or `Lair`. Attaching a map allows every change that's made to it to be saved. We recommend adding a dedicated combatant for this, instead of a player or a monster, to prevent the map from vanishing when a player exits combat, or a monster is killed. Regardless, you can manually attach the map to any other combatant by running `-attach <target>`.

             If these walls and objects are run when they aren't attached to a `-attach` target, then the change will be temporary, and will be removed the next time you run the `!map` command.

             **__Walls and Doors__**
             Check our [Walls and Doors Guide](http://docs.otfbm.com/#/wallsanddoors) for detailed explanations of the commands below.

             __Walls__
             `-wall <coordinate><coordinate>` - Draws a wall directly onto the grid, between two coordinates. Example: `-wall B3J3_B6J6` would draw a line from B3 to J3, and another from B6 to J6. Walls can be added one at a time, or multiple at a time with multiple `-wall`.
             `-deletewall <code>` - Allows you to delete an individual wall

             __Doors__
             You can add doors to walls with following arguments:
             `-o` - Open Door.
             `-d` - Closed Door.
             `-b` - Double Door.
             `-s` - Secret Door.
             Put one of these arguments between two coordinates that make a wall to draw a door in the middle. Example: `-wall B3-oD3` would draw an open door between B3 and D3.

             **__Objects__**
             `-object <location>:<object>` - Adds an object to the map. Some objects can be placed over multiple squares, to do so add a second coordinate after the first. Example: `-object A1B4:trap` would expand an trap object from A1 to B4. Objects can be added one at a time, or multiple at a time with multiple `-object`.
             `-deleteobject <location>:<object>` - Deletes the specified object from the map

             __List of Objects__
             `Trap`
             `Pillar Round`
             `Pillar Square`
             `Statue`
             `Open Pit`
             `Covered Pit`"
             """
 else:
  help = f"""-title "Dude, where did I park my Tarrasque?"
             -desc "**__First time using this alias?__**
             Check our [Getting Started Guide](http://docs.otfbm.com/#/guides_getting_started) to learn how to set up your first map.

             **__Basic commands__**
             `!map` - Shows the map.
             `!map [args]` - Edits the map, its combatants, or its overlays. The several arguments are all explained in these help screens.
             `!map status` - Shows the map's details.
             `!map clear`- Clears all notes, tokens, and overlays from every combatant.
             `!map undo` - Reverts all combatants to the state of last time you ran a `!map` command. You only have one undo, and running `!map undo` a second time undoes it. This information is kept in the `mapStates` uvar, keyed to the channel ID.
             `silent` - This will hide the map for a smaller embed when changing settings.

             **Tokens**

             **__Targeting Combatants__**
             `-t <target>` - Targets a combatant and, paired with the following arguments, changes its token. Without `-t` the argument will apply to the active combatant.
             `-t <target>|[location]|[size]|[color]|[token]` - Allows mass moving/editing targets. You can have many of these in one command, and if you don't want to set a particular arg, leave it blank. `-t WO1||Large` would set it to large, without changing its color, location, or token.

             __Placing or Moving Tokens__
             `-move <coordinate>` - Places a token or moves it to the specified coordinate.
             `!move <coordinate>` - As an alternative to `-move`, this alias moves the active combatant with a shorter command.

             __Customizing tokens__
             `-color <color>` - Sets the token's colour. `-color none` will reset it. Valid colours below.
             `-tokenimport <url>` - Takes an image url and prints its shortcode.
             `-token <shortcode>` - Places an image on a targeted token.
             `-size <size>` - Sets the token's size. `-size none` will reset it. Valid sizes below.
             `-height <+/-#>` - Sets the target's position relative to the ground, which will be displayed above the map."

             -f "_ _|__Other commands__
             `-note <note>` - Sets an arbitrary note on the target.
             `-t <target> status` - Shows the target's details.
             `-savetoken <tokenName>:<shortcode>` - Saves a token to your `mapTokens` uvar. `!map tokenlist` to see your saved tokens. 
             `-deletetoken <tokenName>` - Deletes a token you have saved
             `-loadtoken <tokenName>` - Allows you to load a saved token to a target. Example: `!map -t go1 -loadtoken goblin`

             **__Additional Information__**
             The map calculates distances based on 5ft diagonals. If you would rather 'True' distances, run `!uvar trueDistance true`. To revert back, use `!uvar delete trueDistance`. You can also set this at a server level with `!svar trueDistance true`" """ + colorhelp + sizehelp

 help += helpindex
 if not combat():
  help += f""" -f "Important Note|This alias uses the initiative tracker, and as such, won't work outside of init." """

 return '\n'.join([i.lstrip() for i in help.split('\n')])
</drac2>

<drac2>
paginFooter = ""
if any(args.last(arg) for arg in ('maplist','bglist','backgroundlist','viewlist','spelllist','spellbook')):
 paginFooter = f" | Page {args.last('page', 1)} / #### | -page # to change page"
 if any(args.last(arg) for arg in ('spelllist','spellbook')):
  paginFooter = paginFooter.replace("####", str(len(spellPagin))) if len(spellPagin) > 1 else ""
 elif any(args.last(arg) for arg in ('maplist','bglist','backgroundlist')):
  paginFooter = paginFooter.replace("####", str(len(mapPagin))) if len(mapPagin) > 1 else ""
 elif args.last("viewlist"):
  paginFooter = paginFooter.replace("####", str(len(presetPagin))) if len(presetPagin) > 1 else ""
 paginFooter += " | -search [name] to search"
</drac2>
-footer "!map ?{{f" | Map settings attached to {mapattach.name}" if mapattach else ""}}{{paginFooter}} | v2.1"
<drac2>
# this is for debugging, only display in testing channels
if args.last('debug'):
 return f"""-f "Debug (Only appears in this channel)|```{overlays=}
 {people=}
 {debug=}
 {objects=}
 {walls=}```" """
</drac2>
-color <color>